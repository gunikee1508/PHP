print_r -> print array.

array multidimensional:
<?php
$carros[0][0] = 'GM';
$carros[0][1] = 'Cobalt';
$carros[0][2] = 'Camaro';

$carros[1][0] = 'Ford';
$carros[1][1] = 'Fiesta';
$carros[1][2] = 'Eco Sport';
print_r($carros);

echo $carros[0][2];
echo end($carros[1]); // esta funçao 'end' diz: traga o ultimo elemento dentro desta posição.
?>

<?php
$pessoas = array();
array_push($pessoas, array(
'nome' => 'Luiz',
'idade' => 20
)); // espera adicionar qual o array alvo que voce adicione um item. no caso, quero adicionar no array '$pessoas' outro array.

array_push($pessoas, array(
    'nome' => 'Glaucio',
    'idade' => 45
));

print_r($pessoas[0]['nome']); // mostraria 'Luiz'

?>

// Transformando array em JSON
JSON é um tipo de arquivo que facilita a integraçao dos sistemas, entao tenho sistema em php, alguem em java, e posso gerar um JSON com meus dados e voce com o Java pode consumir essa informação. JSON economiza caracteres, é utilizado praticamente em qualquer linguagem. no JSON, eu pego as variáveis e serializo, ou seja, consigo vê-las no arquivo.

JSON_encode -> para transformar array em JSON, e o contrário, que é pra transformar um JSON em array (JSON_decode);

<?php
$pessoas = array();
array_push($pessoas, array(
'nome' => 'Luiz',
'idade' => 20
)); // espera adicionar qual o array alvo que voce adicione um item. no caso, quero adicionar no array '$pessoas' outro array.

array_push($pessoas, array(
    'nome' => 'Glaucio',
    'idade' => 45
));

$jsonEncode = json_encode($pessoas); // ele espera que voce passe um array para vc encodar ele. transformei array em json.
echo $jsonEncode;

echo '<pre>';

$data = json_decode($jsonEncode, true); // transformei o json em array novamente. precisa colocar 'true', se não ele transforma o indice do subarray em object.
var_dump($data);

?>


// Constantes e arrays Constantes
<?php

//Para criar uma constante, usemos a função 'define'
define('SERVIDOR', '127.0.0.1'); // precisa passar 2 parametros, o primeiro é o nome da constante, e o segundo parametro é o valor que essa constante vai ter. uma convenção é usar constantes com letras maiusculas. lembrando que não pode usar espaços dentro do nome da constante.
echo SERVIDOR; // pra mostrar, é a mesma coisa que variavel, com exceção do dólar. só tirar o dolar. 

//Para fazer array constante:
define("BANCO_DE_DADOS", [
    '127.0.0.1',
    'root',
    'pass',
    'teste' 
], true); // basta usarmos os colchetes apos a definiçao do nome da constante para definir o array constante, no caso, definimos 1 array e seus indices são os requisitos para autenticação. colocamos 'true' pra permitir que chame se o nome do array constante estiver maiusculo ou não.

print_r(BANCO_DE_DADOS);

// veja outra constante:
echo PHP_VERSION;

echo '<br>';

echo DIRECTORY_SEPARATOR; // uma constante bem utilizada, ele traz uma barra de diretorio

?>

// so usar no php.net pra ver as constantes pré definidas

// SESSÕES
variável local != variável de sessão

a partir q o usuario acessa um site, é criada uma sessão entre o usuario e o servidor. qd vc acessa um site, tipo google, cria-se um arquivo temporario na sua maquina, e na maquina do servidor, então amarra as informações. 

// arquivo chamado 'config.php'
<?php
session_start(); // a partir deste momento, as sessões estão funcionando.
$_SESSION['nome'] = 'HCode'; // a session é um array super global. cria-se uma chave pra guardar um valor q vc queira.

//em outro arquivo, agora:
session_start();
echo $_SESSION['nome'];

// toda página em que voce usar sessão, tem que ter: session_start(); , é ideal que usemos um require.
// em outro arquivo:
require_once("config.php");
echo $_SESSION['nome'];

// Para destruir uma variavel de sessão, com nome:
session_unset($_SESSION['nome']); // apaga so a variável de sessão 'nome'
session_unset(); // vai apagar todas as variáveis de sessão

temos também o session_destroy. mas, ql diferença entre session_unset e session_destroy? o session_destroy limpa a variavel e remove o usuario do site. se der F5, é como se fosse um novo acesso no servidor.

?>


///////
 // ID De sessão

ID de sessão é uma identificação unica no seu servidor. quem gera os IDs são o servidores. mas, como descobrir qual seu proprio ID? as vezes gera um cookie, temos tbm o session_storage que guarda no navegador, pra q qd vc volte, retorne as informações.


<?php
require_once('config.php');
echo session_id; // vai mostrar seu ID de sessão. é sempre o mesmo ID de sessão enquanto vc estiver nesta sessão. este valor é unico entre voce e o servidor

session_regenerate_id(); // aqui gera novo id de sessão sempre que voce dá F5 na página. se voce der var_dump($_SESSION), vai mostrar o array superglobal.

// e para recuperar sua sessão? como faria?
session_id('fgdg6d7f67gdf78'); aqui voce coloca a sessão que voce quer recuperar.

?>

/////////

Funções para sessão
para saber onde tá salvando a sessão, use:
<?php
require_once('config.php');
echo session_save_path();

// todas essas funçoes, dá pra ver no site do php em documentações
var_dump(session_status()); // aqui ve-se o status da sessão

/////////////////

Criando funções de usuário-
que é quando o usuario cria sua propria função, basicamente é quando voce tem oq pode ou n acontecer de forma bem especifica.
toda funçao tem que retornar algo, senão retornar, é uma subrotina, isto é, uma rotina que voce reutiliza.

<?php
function ola(){

    return 'Olá mundo!<br>';

}
echo ola(); // é ideal que voce use o return, e dizer que é q vc quer retornar na tela, apenas. se vc quisesse jogar num banco de dados, não apenas retornar na tela, ou guardar na variável.
?>

$frase = ola();
echo strlen($frase); // eu tenho liberdade com o return, posso fazer exatamente o que eu quiser.

<?php

function salario() {
    return 946.00;
}

echo 'José recebeu 3 salários: ". (salario);
?>

//////////

Parametros na função
<?php
function ola($texto) {
    return "Olá $texto";
}

echo ola("Lorem Ipsum"); // mostraria Olá Lorem Ipsum

?>

// pra dar um valor padrao e assim nao precisar ter q passar nada como parametro:
<?php
function ola($texto = Lorem Ipsum, $periodo="Bom dia") {
    return "Olá $texto, $periodo";
}

echo ola(); // mostraria Olá Lorem Ipsum
echo ola("", "Boa noite");
echo ola("Glaucio", "Boa tarde");
echo ola("Glaucio");
?>

// OBS:
<?php
function ola($texto, $periodo="Bom dia") {
    return "Olá $texto, $periodo";
}

echo ola(); // daria erro, pq embora periodo tenha valor padrao, 'texto' não tem, então faltaria parametro.
?>

// então, a ordem NO PHP é sempre da esquerda para direita. sempre tenho q passar primeiro o primeiro parametro, pra dps passar o segundo. parametros que não têm valor padrão, portanto, coloquem sempre à esquerda.

<?php

function ola() {
    $argumentos = func_get_args(); // com essa funçao, ele obtem todos os argumentos passados para a função (no caso, função ola)

    return $argumentos;
}

var_dump(ola("Bom dia!", 10)); // vc sabe que o primeiro parametro foi uma string, e o segundo foi inteiro int

?>

//////////

Passagem de parametro por valor x por referencia

$a = 10;

function trocaValor($a) {
    $a += 50;
    return $a;
}

echo $a; // mostar 10
echo "<br>";
echo trocaValor($a); // mostraria 50
echo $a; // vai mostrar '10' de novo, pq oq acontece na funçao, vale dentro da função, então $a não alterou o valor de 'a'.

// para fazer passagem de valor por referência, usemos '&' antes do cifrão.
function trocaValor(&$a) {
    $a += 50;
    return $a;
} // agora, ao alterar aí dentro da função, irá alterar fora tb, o valor de $a tbm muda. portanto, isto se chama passagem de valor por referencia. ao passar normal, sem que altere fora do escopo da funçao, chama-se passagem de parametro por valor.

se chamar inclusive 2 vezes a funçao, altera 2 vezes, isto é, faz 2 vezes o $a += 50. 

veja outro ex:

<?php

$pessoa = array(
    'nome' => 'João',
    'idade' => 18
);

foreach($pessoa as &$valor) { // quando tiver passando no foreach, quero alterar os dados do array. fiz a referencia no foreach
    if(gettype($valor) === 'integer') $valor += 10; // gettype pega o tipo de valor da variável
    echo $valor.'<br>';
}

print_r($pessoa);
?>

//////////////


... no parametro significa que voce recebe não parâmetro na funçao do php:

function soma(int ...$valores):string  // vai pegar todos os parametros do array (array $valores) de uma vez so. o ':' significa que voce vai retornar algo, e voce vai retornar o tipo, o tipo String. é a conversão do tipo no retorno
{

    return array_sum($valores); // funçao do php que ja soma todos os valores.

}

echo var_dump(soma(2, 2));
echo "<br>";
echo soma(29, 33);
echo "<br>";
echo var_dump(soma(1.5, 3.2));
echo "<br>";

/\ verá que todos os numeros que tao mostrando agora, de inteiro viraram strings.

/////////////

Função recursiva - quando uma funçao chama a si mesmo.
lembrando, no php, lista para tags ordenadas, <ol>, listas nao ordenadas, <ul>.

funçao recursiva não deve ser sempre a primeira funçao, tente resolver com foreach ou while antes, pois funçao recursiva consome muito.

<?php

$hierarquia = array(
    array(
        'nome_cargo' => 'CEO',
        'subordinados' => array(
            array(
                'nome_cargo' => 'Diretor Comercial',
                'subordinados' => array(
                    array(
                        'nome_cargo' => 'Gerente de Vendas'
                    )
                )
            ),
            array(
                'nome_cargo' => 'Diretor Financeiro',
                'subordinados' => array(
                    array(
                        'nome_cargo' => 'Gerente de Contas a Pagar',
                        'subordinados' => array(
                            array(
                                'nome_cargo' => 'Supervisor de Pagamentos'
                            )
                        )
                    )
                )
            ),
            array(
                'nome_cargo' => 'Gerente de Compras',
                'subordinados' => array(
                    array(
                        'nome_cargo' => 'Supervisor de Suprimentos'
                    )
                )
            )
        )
    )
);

// isset é validação de variável, pra ver se ela existe (foi definida) ou não.

function exibe($cargos)
{

    $html = '<ul>'; // dentro de uma lista, tenho q ter uma tag <li> pra ir colocando dentro dessas listas. se dentro de uma li, eu tenho outro 'subordinado' (no caso), então tenho q criar outro <ul> e nele colocar outro '<li>'
    
    foreach ($cargos as $cargo) { // cada cargo que eu encontrar vou chamar de 'cargo' no singular. percorrendo o array $cargos, $cargo representa cada elemento do array $cargos em cada iteração do loop.

    .$html .= "<li>";  // usamos dnv .= para concatenar com o que já tem. abrindo a tag "<li>"
    .$html .= $cargo['nome_cargo']; // esta variável $cargo é somente um array

        if(isset($cargo["subordinados"]) && count($cargo['subordinados']) > 0)
        {
            $html .= exibe($cargo['subordinados']); // a funçao recursiva sendo usada aqui a sua recursividade.
        }
    .$html .= "</li>"; // agora, para vermos se tem outro nome_cargo, teria que ver outro foreach, dentro de outro foreach, e assim vai. pra evitar isto, ai usamos as funções recursivas.

    }


    $html .= '</ul>'; // .= para ir acumulando

    return $html;
}

echo exibe($hierarquia);

?>

///////////////////

Funções anonimas -
Mais comum no JS. Sem nome, sem return.

// Um jeito de usar as funçoes anonimas
function test($callback){
    $callback();
}

test(function(){
    echo "Terminou!";
});

// Outro jeito de usar as funçoes anonimas
$fn = function($a){
    var_dump($a);
};

$fn("Oi");

/////////////

POO -
// Usa 'class' e o nome da classe; classe smp começa com letra maiuscula.
class Pessoa {
    public $nome; // atributo

    public function falar() { // método (funçao dentro de uma classe)
        return "O meu nome é ".$this->nome; // quero acessar meu proprio atributo nome. acessamos com o $this-> pra acessar uma informaçao dela, o this é a representaçao da nossa classe já instanciada, ou seja, o objeto. ATENÇÃO: dentro de um método, qualquer método, pra eu fazer referencia a um atributo que tá fora, devo usar $this->NOMEDOATRIBUTO. $this-> serve pra referenciar atributos e métodos dentro de métodos.
    }
} 

$glaucio = new Pessoa(); // não tem metodo construtor e colocamos () aqui, mas aqui foi força do habito, e como nao temos neste caso metodo construtor, esse parametro é opcional.
$glaucio->nome = "Glaucio Daniel"; // referenciando um atributo, mesmo de fora, eu consigo acessar ele pq ele é publico
echo $glaucio->falar();

////////////

atributos e métodos.

class Carro {
    private $modelo;
    private $motor;
    private $ano;

    public function getModelo() { //metodos getters e setters agora.
        return $this->modelo;
    }

    public function setModelo($modelo) {
        $this->modelo = $modelo; // aqui, são coisas diferentes. this modelo vai receber o valor do modelo passado como parametro, e this modelo aqui no caso vai ser o atributo lá em cima.
    }

    public function getMotor():float { // esperamos receber apenas float, entao colocamos o :float
        return $this->motor;
    }

    public function setMotor() {
        $this->motor = $motor;
    }

    // !!!!!!!!!! VEJA QUE EM MÉTODOS SET, não precisa retornar, afinal so muda o atributo, se eu quiser mostrar o atributo, eu o mostro com o get.

    public function getAno():int { // mesma coisa aqui, esperamos receber apenas int para ano.
        return $this->ano;
    }

    public function setAno() {
        $this->ano = $ano;
    }


}


/////////////////

Métodos estáticos - acessar métodos sem precisar instanciar um objeto.

class Documento {
    private $numero;

    public function getNumero() 
    {
        return $this->numero;   
    }

    // quando alguem definir um novo numero, podemos testar o método. para chamar, usamos o :: para chamar um método estático.,
    public function setNumero($numero) 
    {
        $resultado = Documento::validarCPF($numero); // NOMEDACLASSE::NOMEDOMÉTODOESTÁTICO. invocou o método
        if($resultado == false) {
            throw new Exception("CPF informado não é válido", 1);
        }
        $this->numero = $numero;
    }

    public static function validarCPF($cpf):bool { // botei 'bool' aqui pq é o que esperamos receber. 
        if(empty($cpf)) {
            return false;
        }
     
        $cpf = preg_match('/[0-9]/', $cpf)?$cpf:0;
    
        $cpf = str_pad($cpf, 11, '0', STR_PAD_LEFT);
         
        
        if (strlen($cpf) != 11) {
            echo "length";
            return false;
        }
        
        else if ($cpf == '00000000000' || 
            $cpf == '11111111111' || 
            $cpf == '22222222222' || 
            $cpf == '33333333333' || 
            $cpf == '44444444444' || 
            $cpf == '55555555555' || 
            $cpf == '66666666666' || 
            $cpf == '77777777777' || 
            $cpf == '88888888888' || 
            $cpf == '99999999999') {
            return false;
    
         } else {   
             
            for ($t = 9; $t < 11; $t++) {
                 
                for ($d = 0, $c = 0; $c < $t; $c++) {
                    $d += $cpf[$c] * (($t + 1) - $c);
                }
                $d = ((10 * $d) % 11) % 10;
                if ($cpf[$c] != $d) {
                    return false;
                }
            }
     
            return true;
        }
    }
}

$cpf = new Documento();
$cpf->setNumero("25650599068");
var_dump($cpf->getNumero());
var_dump(Documento::validarCPF("25650599068")); // retorna true

////////////////

Métodos Mágicos -
Quando tiver algum acontecimento, pode definir algumas açoes pra esse acontecimento. Método construtor é algo que é executado automaticamente quando um objeto é instanciado.
Todos métodos mágicos começarão com __ no nome.
Sempre quando for construir um método construtor, usa o __construct. o construtor é um método mágico.

class Endereco {
    private $logradouro;
    private $numero;
    private $cidade;
    // queremos que, quando instancie uma classe, possa passar o logradouro e o numero da cidade

    public function __construct($a, $b, $c) { // não necessariamente os parametros do construtor precisam ter o mesmo nome do atributo. aqui, __construct é nosso construtor, nosso método mágico.
        $this->logradouro = $a;
        $this->numero = $b;
        $this->cidade = $c;
    }

    // Assim como temos o construct, temos o destruct. O destruct é chamado quando o objeto é destruido, quando ele é removido da memória, podendo ser quando a pagina chega no fim da execução ou se falar que quer que tire da memória, usando o 'unset'. pode-se usar o destruct quando quiser matar variaveis ou desconectar-se do banco de dados, etc. é bom pra automatizar.
    public function __destruct()
    {
        var_dump("DESTRUIR");
    }

    // temos também outro atributo. quando queremos transformar algo em string basicamente. é o __toString.
    public function __toString() {
        return $this->logradouro.", " .$this->numero." - " .$this->cidade;
    }

}

$meuEndereco = new Endereco("Rua Zeferino", "123", "Rio de Janeiro"); // agora precisamos passar os 3 parametros, ja que temos construtor
var_dump($meuEndereco);
unset($meuEndereco);

///////////////

Encapsulamento - 
é proteger/controlar quem pode ver o que. encapsulamento protege as informações. ele faz diferença na herança, onde uns atributos e métodos serão enxergados apenas na classe que a define, e outros métodos e atributos poderão ter na classe filha.

class Pessoa {
    public $nome = "Conor";
    protected $idade = 35; // somente os herdeiros da classe, as classes filhas, poderão acessar este atributo
    private $senha = "123456";

    public function verDados() {
        echo $this->nome . "<br/>";
        echo $this->idade . "<br/>";
        echo $this->senha . "<br/>";
    }
}

$objeto = new Pessoa();

echo $objeto->nome . "<br/>";
$objeto->verDados(); // como o método 'verDados' é público, todos os dados apareceram.

// public todos podem ver. protected so as filhas podem ver. private somente aquela classe pode ver.

class Pessoa {
    public $nome = "Conor";
    protected $idade = 35; // somente os herdeiros da classe, as classes filhas, poderão acessar este atributo
    private $senha = "123456";

    public function verDados() {
        echo $this->nome . "<br/>";
        echo $this->idade . "<br/>";
        echo $this->senha . "<br/>";
    }
}

class Programador extends Pessoa {
    public function verDados() {
        echo get_class($this) . "<br/>"; // irá mostrar o nome da classe do objeto atual.
        echo $this->nome . "<br/>";
        echo $this->idade . "<br/>";
        echo $this->senha . "<br/>"; // aqui irá dar erro pq senha é privado
    }
}

$objeto = new Programador();

echo $objeto->nome . "<br/>";
$objeto->verDados(); // vai funcionar pq, programador herdou de 'Pessoa' o método 'verDados' q é publico. se fosse private, nao iria funcionar.


///////////////

herança - 
por ex
tudo que for de comum entre diversos tipos de veiculos de locomoçao, como navio, moto, carro, etc, posso ter uma classe base. e dessa vc herda pra fazer classes pra fazer coisas especificas, desde que nao tenham algo tao em comum (que possa ficar em uma classe intermediaria). isso é abstração. uma UML bem feita codifica qualquer objeto.

class Documento {
    private $numero; // um documento sempre vai ter um numero
    public function getNumero() {
        return $this->numero;
    }
    public function setNumero($n) {
        $this->numero = $n;
    }

}

class CPF extends Documento {
    public function validar():bool 
    {
        $numeroCPF = $this->getNumero();
        // Validação do CPF, aqui coloca o codigo de validaçao do cpf.
        return true;
    }
}

$doc = new CPF();

$doc->setNumero("111222333-44");

$doc->validar();

var_dump($doc->validar());

echo "<br/>";

echo $doc->getNumero();

/////////////////

INTERFACE:
Ajuda bastante a organizar o código, pq ele determina padrões, por ex, vou fazer um documento, então ele precisa ter um método de validação do documento, ou um método que vai salvar este documento no banco de dados. Você o obriga a ter um determinado padrão. Determina padrões q voce vai ter que fazer. dentro da interface eu digo quais metodos tal coisa vai ter, quais parametros vai ter e qual o modificador de acesso ou encapsulamento os metodos vai ter. na interface não digo o que faz. a classe q implementar essa interface so vai funcionar quando bater 100% com a interface.

interface Veiculo { // o que um veiculo precisaria ter? vamos escrever aqui alguns dos padrões
    public function acelerar($velocidade);
    public function frear($velocidade);
    public function trocarMarcha($marcha);
} 

class Civic implements Veiculo {
    
}

$carro = new Civic(); // se eu rodar somente isto, verá q dará erro, pois irá mostrar que os métodos declarados na interface Veiculo, precisam ser declarados na classe Civic tbm, pq ela implementa a interface Veiculo.

// VEJA AGORA:

interface Veiculo { // o que um veiculo precisaria ter? vamos escrever aqui alguns dos padrões
    public function acelerar($velocidade);
    public function frear($velocidade);
    public function trocarMarcha($marcha);
} 

class Civic implements Veiculo {
    public function acelerar($velocidade)
    {
        echo "O veículo acelerou até " . $velocidade . "km/h";
    }

    protected function frear($velocidade)
    {
        echo "O veículo freou até " . $velocidade . "km/h";
    }

    public function trocarMarcha($marcha)
    {
        echo "O veículo engatou a marcha " .$marcha;
    }
}

$carro = new Civic();
$carro->acelerar(150);
echo "<br/>";
$carro->trocarMarcha(1);
echo "<br>";

// util ate pra integraçao de apis, isto é, pra codigos de terceiros.

// ---------> A DIFERENÇA ENTRE INTERFACE E CLASSE ABSTRATA: uma classe pode implementar várias interfaces.

////////////
CLASSE ABSTRATA-
A diferença aqui e a da interface, tbm, é q nao apenas definimos os métodos que precisamos ter, mas tbm oq eles fazem. uma diferença de classe abstrata pra classe comum é que o objeto nunca vai instanciar uma classe abstrata. crio uma classe, q vai ser abstrata, etals, e, pra usá-la, crio OUTRA classe que vai extender dessa classe abstrata e vai respeitar as definições.

interface Veiculo { // o que um veiculo precisaria ter? vamos escrever aqui alguns dos padrões
    public function acelerar($velocidade);
    public function frear($velocidade);
    public function trocarMarcha($marcha);
} 

abstract class Automovel implements Veiculo { // qq automóvel implementa a interface Veículo, precisa ter esses metodos com esses atributos.
    public function acelerar($velocidade)
    {
        echo "O veículo acelerou até " . $velocidade . "km/h";
    }

    protected function frear($velocidade)
    {
        echo "O veículo freou até " . $velocidade . "km/h";
    }

    public function trocarMarcha($marcha)
    {
        echo "O veículo engatou a marcha " .$marcha;
    }
}

class DelRey extends Automovel {
    // aqui a classe DelRey pode ter suas coisas especificas, de seu veiculo.
    public function empurrar() {

    }
}

$carro = new DelRey(); // daí não posso instanciar um objeto direto da classe abstrata Automovel.
$carro->acelerar(200);

// uma classe vai herdar somente de uma classe abstrata, mas uma classe pode implementar várias interfaces

///////////////

Polimorfismo - classes com o mesmo nome possuem comportamentos diferentes.
abstract class Animal {
    public function falar(){
        return "Som";
    }
    public function mover(){
        return "Anda";
    }
}

class Cachorro extends Animal {
    public function falar() { // houve polimorfismo, mudou o comportamento
        return "Late";
    }
}

// Agora criei outra classe, Passaro.
class Passaro extends Animal {
    public function falar() { // houve polimorfismo, mudou o comportamento
        return "Canta";
    }

    public function mover() {
        return "Voa e " . parent::mover(); // aqui, ele diz: chame o método 'mover' da classe 'Animal', que é a classe pai. vc chama algum metodo da classe pai.
    }
}

class Gato extends Animal {
    public function falar() { // houve polimorfismo, mudou o comportamento
        return "Mia";
    }
}

$pluto = new Cachorro();
echo $pluto->falar() . "<br/>";
echo $pluto->mover() . "<br/>";

$garfield = new Gato();
echo $garfield->falar() . "<br/>";

$ave = new Passaro();
echo $ave->mover();

//////////////

Incluindo classes com AutoLoad -
Digamos por exemplo que seu projeto precise de 4 ou 5 classes, será q precisariamos de require_once para cada uma delas? Aí entra o AutoLoad. É uma função do PHP para que carregue as classes automaticamente sem que use o require. a funçao autoload ficaria em um arquivo e esse arquivo iria como include para cada um dos outros projetos. 

quero simplesmente criar um novo DelRey, instanciar um novo DelRey.

// o autoload so sabe procurar as classes no mesmo diretório.

function incluirClasses($nomeClasse){
    if (file_exists($nomeClasse.".php") === true) {
        require_once($nomeClasse.".php");
    }
}

spl_autoload_register("incluirClasses"); // registra a função 'incluirclasses' como uma função de AutoLoad.
spl_autoload_register(function($nomeClasse){
    if (file_exists("Abstratas". DIRECTORY_SEPARATOR . $nomeClasse.".php") === true) {
        require_once("Abstratas" . DIRECTORY_SEPARATOR . $nomeClasse.".php");
    }
});

$carro = new DelRey(); // quando você cria uma instância de DelRey, o PHP tentará carregar a classe DelRey. Se o arquivo DelRey.php existir no mesmo diretório do script, ele será incluído. Se não existir, o PHP tentará carregar a classe a partir do diretório "Abstratas", se aplicável.

$carro->acelerar(80); // Se a classe DelRey estiver no arquivo DelRey.php no mesmo diretório do script ou no diretório "Abstratas", e se a classe tiver o método acelerar(80), então o código deverá funcionar corretamente.

// /\ Abstratas, em cima, é o nome do diretório em que talvez o arquivo possa estar. 

//////////////////

NameSpace - 
NameSpace permite agrupar as classes dentro de diretórios de uma forma organizada. Aí entra a diferenciação, dividir em espaços diferentes, daí namespace, dar nome para os espaços.

// Devemos dizer onde ele vai procurar as classes.
spl_autoload_register(function($nameClass){
    $dirClass = "class"; // a pasta onde o php deve procurar nossas pastas. nas aulas, essa é o nome da pasta onde tem as classes.
    $filename = $dirclass . DIRECTORY_SEPARATOR . "$nameClass" . ".php";
    if(file_exists($filename)) {
        require_once($filename);
    }
    
});

// Use a constante DIRECTORY_SEPARATOR que o php irá se adaptar pra unix ou windows.

um arquivo cadastro (!!!! lembrando que o nome da classe SEMPRE deve ser igual ao nome do arquivo):
class Cadastro {
    private $nome;
    private $email;
    private $senha;

    public function getNome():string 
    {
        return $this->nome;
    }

    public function getEmail():string 
    {
        return $this->email;
    }

    public function getSenha():string 
    {
        return $this->senha;
    }

    public function setNome($nome)
    {
        $this->$nome = $nome;
    }

    public function setEmail($email)
    {
        $this->$email = $email;
    }

    public function setSenha($senha)
    {
        $this->$senha = $senha;
    }

    public function __toString() {
        return json_encode(array(
            "nome"=>$this->getNome(),
            "email"=>$this->getEmail(),
            "senha"=>$this->getSenha(),
        ));
    }

}

dentro de uma pasta chamada 'namespace', criamos um arquivo, chamado index.php.
abramos o index.php, e digitemos:
require_once("config.php");

$cad = new Cadastro();

$cad->setNome("Luiz");
$cad->setEmail("luiz@hcode.com");
$cad->setSenha("12345");

echo $cad; // o 'echo' não consegue mostrar um objeto, só mostra texto. mas o objeto sabe virar string, q é o __toString.

// digamos que eu tivesse uma subpasta cliente e dentro dela eu tivesse uma outra pasta q seria o cadastro desse cliente, pq vc pode ter cadastro de cliente, de fornecedor, de funcionario, de instrutor... criemos um namespace apenas para o cadastro do cliente.
criemos uma pasta 'cliente' dentro da pasta 'class', e dentro dessa pasta cliente teremos o cadastro de um cliente. criemos o arquivo dentro 'Cadastro.php'.
class Cadastro extends {
    public function registrarVenda() {
        echo "Foi registrada uma venda para o cliente " .$this->getNome(); // da onde vem esse getNome? ela tem que herdar do Cadastro Principal. essa classe, precisamos informar que ela está em um nameSpace. devemos entao informar o namespace desse arquivo.
    }
}
\/

namespace Cliente;
use 
class Cadastro extends \Cadastro{ // volta na raiz e lá acha a classe Cadastro
    public function registrarVenda() {
        echo "Foi registrada uma venda para o cliente " .$this->getNome(); // da onde vem esse getNome? ela tem que herdar do Cadastro Principal. essa classe, precisamos informar que ela está em um nameSpace. devemos entao informar o namespace desse arquivo. colocamos de nome "Cliente"
    }
}

agora, no arquivo index.php
// Precisamos usar a classe do NameSpace, pra usar um nameSpace, uso a palavra-chave "use":
use Cliente\Cadastro; // NAMESPACE\CLASSE -> quero usar o namespace 'Cliente' e a classe 'Cadastro', então, agora, no index.php, ao ver o "$cad = new Cadastro(); ", o Cadastro será o cadastro que está dentro de Cliente.

o cadastro que tá dentro do namespace Cliente' é diferente do cadastro que tá na raiz de class. o cadastro do cliente precisa compartilhar informações com qualquer tipo de cadastro, então extende da classe raiz. 