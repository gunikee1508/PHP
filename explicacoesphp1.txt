print_r -> print array.

array multidimensional:
<?php
$carros[0][0] = 'GM';
$carros[0][1] = 'Cobalt';
$carros[0][2] = 'Camaro';

$carros[1][0] = 'Ford';
$carros[1][1] = 'Fiesta';
$carros[1][2] = 'Eco Sport';
print_r($carros);

echo $carros[0][2];
echo end($carros[1]); // esta funçao 'end' diz: traga o ultimo elemento dentro desta posição.
?>

<?php
$pessoas = array();
array_push($pessoas, array(
'nome' => 'Luiz',
'idade' => 20
)); // espera adicionar qual o array alvo que voce adicione um item. no caso, quero adicionar no array '$pessoas' outro array.

array_push($pessoas, array(
    'nome' => 'Glaucio',
    'idade' => 45
));

print_r($pessoas[0]['nome']); // mostraria 'Luiz'

?>

// Transformando array em JSON
JSON é um tipo de arquivo que facilita a integraçao dos sistemas, entao tenho sistema em php, alguem em java, e posso gerar um JSON com meus dados e voce com o Java pode consumir essa informação. JSON economiza caracteres, é utilizado praticamente em qualquer linguagem. no JSON, eu pego as variáveis e serializo, ou seja, consigo vê-las no arquivo.

JSON_encode -> para transformar array em JSON, e o contrário, que é pra transformar um JSON em array (JSON_decode);

<?php
$pessoas = array();
array_push($pessoas, array(
'nome' => 'Luiz',
'idade' => 20
)); // espera adicionar qual o array alvo que voce adicione um item. no caso, quero adicionar no array '$pessoas' outro array.

array_push($pessoas, array(
    'nome' => 'Glaucio',
    'idade' => 45
));

$jsonEncode = json_encode($pessoas); // ele espera que voce passe um array para vc encodar ele. transformei array em json.
echo $jsonEncode;

echo '<pre>';

$data = json_decode($jsonEncode, true); // transformei o json em array novamente. precisa colocar 'true', se não ele transforma o indice do subarray em object.
var_dump($data);

?>


// Constantes e arrays Constantes
<?php

//Para criar uma constante, usemos a função 'define'
define('SERVIDOR', '127.0.0.1'); // precisa passar 2 parametros, o primeiro é o nome da constante, e o segundo parametro é o valor que essa constante vai ter. uma convenção é usar constantes com letras maiusculas. lembrando que não pode usar espaços dentro do nome da constante.
echo SERVIDOR; // pra mostrar, é a mesma coisa que variavel, com exceção do dólar. só tirar o dolar. 

//Para fazer array constante:
define("BANCO_DE_DADOS", [
    '127.0.0.1',
    'root',
    'pass',
    'teste' 
], true); // basta usarmos os colchetes apos a definiçao do nome da constante para definir o array constante, no caso, definimos 1 array e seus indices são os requisitos para autenticação. colocamos 'true' pra permitir que chame se o nome do array constante estiver maiusculo ou não.

print_r(BANCO_DE_DADOS);

// veja outra constante:
echo PHP_VERSION;

echo '<br>';

echo DIRECTORY_SEPARATOR; // uma constante bem utilizada, ele traz uma barra de diretorio

?>

// so usar no php.net pra ver as constantes pré definidas

// SESSÕES
variável local != variável de sessão

a partir q o usuario acessa um site, é criada uma sessão entre o usuario e o servidor. qd vc acessa um site, tipo google, cria-se um arquivo temporario na sua maquina, e na maquina do servidor, então amarra as informações. 

// arquivo chamado 'config.php'
<?php
session_start(); // a partir deste momento, as sessões estão funcionando.
$_SESSION['nome'] = 'HCode'; // a session é um array super global. cria-se uma chave pra guardar um valor q vc queira.

//em outro arquivo, agora:
session_start();
echo $_SESSION['nome'];

// toda página em que voce usar sessão, tem que ter: session_start(); , é ideal que usemos um require.
// em outro arquivo:
require_once("config.php");
echo $_SESSION['nome'];

// Para destruir uma variavel de sessão, com nome:
session_unset($_SESSION['nome']); // apaga so a variável de sessão 'nome'
session_unset(); // vai apagar todas as variáveis de sessão

temos também o session_destroy. mas, ql diferença entre session_unset e session_destroy? o session_destroy limpa a variavel e remove o usuario do site. se der F5, é como se fosse um novo acesso no servidor.

?>


///////
 // ID De sessão

ID de sessão é uma identificação unica no seu servidor. quem gera os IDs são o servidores. mas, como descobrir qual seu proprio ID? as vezes gera um cookie, temos tbm o session_storage que guarda no navegador, pra q qd vc volte, retorne as informações.


<?php
require_once('config.php');
echo session_id; // vai mostrar seu ID de sessão. é sempre o mesmo ID de sessão enquanto vc estiver nesta sessão. este valor é unico entre voce e o servidor

session_regenerate_id(); // aqui gera novo id de sessão sempre que voce dá F5 na página. se voce der var_dump($_SESSION), vai mostrar o array superglobal.

// e para recuperar sua sessão? como faria?
session_id('fgdg6d7f67gdf78'); aqui voce coloca a sessão que voce quer recuperar.

?>

/////////

Funções para sessão
para saber onde tá salvando a sessão, use:
<?php
require_once('config.php');
echo session_save_path();

// todas essas funçoes, dá pra ver no site do php em documentações
var_dump(session_status()); // aqui ve-se o status da sessão

/////////////////

Criando funções de usuário-
que é quando o usuario cria sua propria função, basicamente é quando voce tem oq pode ou n acontecer de forma bem especifica.
toda funçao tem que retornar algo, senão retornar, é uma subrotina, isto é, uma rotina que voce reutiliza.

<?php
function ola(){

    return 'Olá mundo!<br>';

}
echo ola(); // é ideal que voce use o return, e dizer que é q vc quer retornar na tela, apenas. se vc quisesse jogar num banco de dados, não apenas retornar na tela, ou guardar na variável.
?>

$frase = ola();
echo strlen($frase); // eu tenho liberdade com o return, posso fazer exatamente o que eu quiser.

<?php

function salario() {
    return 946.00;
}

echo 'José recebeu 3 salários: ". (salario);
?>

//////////

Parametros na função
<?php
function ola($texto) {
    return "Olá $texto";
}

echo ola("Lorem Ipsum"); // mostraria Olá Lorem Ipsum

?>

// pra dar um valor padrao e assim nao precisar ter q passar nada como parametro:
<?php
function ola($texto = Lorem Ipsum, $periodo="Bom dia") {
    return "Olá $texto, $periodo";
}

echo ola(); // mostraria Olá Lorem Ipsum
echo ola("", "Boa noite");
echo ola("Glaucio", "Boa tarde");
echo ola("Glaucio");
?>

// OBS:
<?php
function ola($texto, $periodo="Bom dia") {
    return "Olá $texto, $periodo";
}

echo ola(); // daria erro, pq embora periodo tenha valor padrao, 'texto' não tem, então faltaria parametro.
?>

// então, a ordem NO PHP é sempre da esquerda para direita. sempre tenho q passar primeiro o primeiro parametro, pra dps passar o segundo. parametros que não têm valor padrão, portanto, coloquem sempre à esquerda.

<?php

function ola() {
    $argumentos = func_get_args(); // com essa funçao, ele obtem todos os argumentos passados para a função (no caso, função ola)

    return $argumentos;
}

var_dump(ola("Bom dia!", 10)); // vc sabe que o primeiro parametro foi uma string, e o segundo foi inteiro int

?>

//////////

Passagem de parametro por valor x por referencia

$a = 10;

function trocaValor($a) {
    $a += 50;
    return $a;
}

echo $a; // mostar 10
echo "<br>";
echo trocaValor($a); // mostraria 50
echo $a; // vai mostrar '10' de novo, pq oq acontece na funçao, vale dentro da função, então $a não alterou o valor de 'a'.

// para fazer passagem de valor por referência, usemos '&' antes do cifrão.
function trocaValor(&$a) {
    $a += 50;
    return $a;
} // agora, ao alterar aí dentro da função, irá alterar fora tb, o valor de $a tbm muda. portanto, isto se chama passagem de valor por referencia. ao passar normal, sem que altere fora do escopo da funçao, chama-se passagem de parametro por valor.

se chamar inclusive 2 vezes a funçao, altera 2 vezes, isto é, faz 2 vezes o $a += 50. 

veja outro ex:

<?php

$pessoa = array(
    'nome' => 'João',
    'idade' => 18
);

foreach($pessoa as &$valor) { // quando tiver passando no foreach, quero alterar os dados do array. fiz a referencia no foreach
    if(gettype($valor) === 'integer') $valor += 10; // gettype pega o tipo de valor da variável
    echo $valor.'<br>';
}

print_r($pessoa);
?>

//////////////


... no parametro significa que voce recebe não parâmetro na funçao do php:

function soma(int ...$valores):string  // vai pegar todos os parametros do array (array $valores) de uma vez so. o ':' significa que voce vai retornar algo, e voce vai retornar o tipo, o tipo String. é a conversão do tipo no retorno
{

    return array_sum($valores); // funçao do php que ja soma todos os valores.

}

echo var_dump(soma(2, 2));
echo "<br>";
echo soma(29, 33);
echo "<br>";
echo var_dump(soma(1.5, 3.2));
echo "<br>";

/\ verá que todos os numeros que tao mostrando agora, de inteiro viraram strings.

/////////////

Função recursiva - quando uma funçao chama a si mesmo.
lembrando, no php, lista para tags ordenadas, <ol>, listas nao ordenadas, <ul>.

funçao recursiva não deve ser sempre a primeira funçao, tente resolver com foreach ou while antes, pois funçao recursiva consome muito.

<?php

$hierarquia = array(
    array(
        'nome_cargo' => 'CEO',
        'subordinados' => array(
            array(
                'nome_cargo' => 'Diretor Comercial',
                'subordinados' => array(
                    array(
                        'nome_cargo' => 'Gerente de Vendas'
                    )
                )
            ),
            array(
                'nome_cargo' => 'Diretor Financeiro',
                'subordinados' => array(
                    array(
                        'nome_cargo' => 'Gerente de Contas a Pagar',
                        'subordinados' => array(
                            array(
                                'nome_cargo' => 'Supervisor de Pagamentos'
                            )
                        )
                    )
                )
            ),
            array(
                'nome_cargo' => 'Gerente de Compras',
                'subordinados' => array(
                    array(
                        'nome_cargo' => 'Supervisor de Suprimentos'
                    )
                )
            )
        )
    )
);

// isset é validação de variável, pra ver se ela existe (foi definida) ou não.

function exibe($cargos)
{

    $html = '<ul>'; // dentro de uma lista, tenho q ter uma tag <li> pra ir colocando dentro dessas listas. se dentro de uma li, eu tenho outro 'subordinado' (no caso), então tenho q criar outro <ul> e nele colocar outro '<li>'
    
    foreach ($cargos as $cargo) { // cada cargo que eu encontrar vou chamar de 'cargo' no singular. percorrendo o array $cargos, $cargo representa cada elemento do array $cargos em cada iteração do loop.

    .$html .= "<li>";  // usamos dnv .= para concatenar com o que já tem. abrindo a tag "<li>"
    .$html .= $cargo['nome_cargo']; // esta variável $cargo é somente um array

        if(isset($cargo["subordinados"]) && count($cargo['subordinados']) > 0)
        {
            $html .= exibe($cargo['subordinados']); // a funçao recursiva sendo usada aqui a sua recursividade.
        }
    .$html .= "</li>"; // agora, para vermos se tem outro nome_cargo, teria que ver outro foreach, dentro de outro foreach, e assim vai. pra evitar isto, ai usamos as funções recursivas.

    }


    $html .= '</ul>'; // .= para ir acumulando

    return $html;
}

echo exibe($hierarquia);

?>

///////////////////

Funções anonimas -
Mais comum no JS. Sem nome, sem return.

// Um jeito de usar as funçoes anonimas
function test($callback){
    $callback();
}

test(function(){
    echo "Terminou!";
});

// Outro jeito de usar as funçoes anonimas
$fn = function($a){
    var_dump($a);
};

$fn("Oi");

/////////////

POO -
// Usa 'class' e o nome da classe; classe smp começa com letra maiuscula.
class Pessoa {
    public $nome; // atributo

    public function falar() { // método (funçao dentro de uma classe)
        return "O meu nome é ".$this->nome; // quero acessar meu proprio atributo nome. acessamos com o $this-> pra acessar uma informaçao dela, o this é a representaçao da nossa classe já instanciada, ou seja, o objeto. ATENÇÃO: dentro de um método, qualquer método, pra eu fazer referencia a um atributo que tá fora, devo usar $this->NOMEDOATRIBUTO. $this-> serve pra referenciar atributos e métodos dentro de métodos.
    }
} 

$glaucio = new Pessoa(); // não tem metodo construtor e colocamos () aqui, mas aqui foi força do habito, e como nao temos neste caso metodo construtor, esse parametro é opcional.
$glaucio->nome = "Glaucio Daniel"; // referenciando um atributo, mesmo de fora, eu consigo acessar ele pq ele é publico
echo $glaucio->falar();

////////////

atributos e métodos.

class Carro {
    private $modelo;
    private $motor;
    private $ano;

    public function getModelo() { //metodos getters e setters agora.
        return $this->modelo;
    }

    public function setModelo($modelo) {
        $this->modelo = $modelo; // aqui, são coisas diferentes. this modelo vai receber o valor do modelo passado como parametro, e this modelo aqui no caso vai ser o atributo lá em cima.
    }

    public function getMotor():float { // esperamos receber apenas float, entao colocamos o :float
        return $this->motor;
    }

    public function setMotor() {
        $this->motor = $motor;
    }

    // !!!!!!!!!! VEJA QUE EM MÉTODOS SET, não precisa retornar, afinal so muda o atributo, se eu quiser mostrar o atributo, eu o mostro com o get.

    public function getAno():int { // mesma coisa aqui, esperamos receber apenas int para ano.
        return $this->ano;
    }

    public function setAno() {
        $this->ano = $ano;
    }


}


/////////////////

Métodos estáticos - acessar métodos sem precisar instanciar um objeto.

class Documento {
    private $numero;

    public function getNumero() 
    {
        return $this->numero;   
    }

    // quando alguem definir um novo numero, podemos testar o método. para chamar, usamos o :: para chamar um método estático.,
    public function setNumero($numero) 
    {
        $resultado = Documento::validarCPF($numero); // NOMEDACLASSE::NOMEDOMÉTODOESTÁTICO. invocou o método
        if($resultado == false) {
            throw new Exception("CPF informado não é válido", 1);
        }
        $this->numero = $numero;
    }

    public static function validarCPF($cpf):bool { // botei 'bool' aqui pq é o que esperamos receber. 
        if(empty($cpf)) {
            return false;
        }
     
        $cpf = preg_match('/[0-9]/', $cpf)?$cpf:0;
    
        $cpf = str_pad($cpf, 11, '0', STR_PAD_LEFT);
         
        
        if (strlen($cpf) != 11) {
            echo "length";
            return false;
        }
        
        else if ($cpf == '00000000000' || 
            $cpf == '11111111111' || 
            $cpf == '22222222222' || 
            $cpf == '33333333333' || 
            $cpf == '44444444444' || 
            $cpf == '55555555555' || 
            $cpf == '66666666666' || 
            $cpf == '77777777777' || 
            $cpf == '88888888888' || 
            $cpf == '99999999999') {
            return false;
    
         } else {   
             
            for ($t = 9; $t < 11; $t++) {
                 
                for ($d = 0, $c = 0; $c < $t; $c++) {
                    $d += $cpf[$c] * (($t + 1) - $c);
                }
                $d = ((10 * $d) % 11) % 10;
                if ($cpf[$c] != $d) {
                    return false;
                }
            }
     
            return true;
        }
    }
}

$cpf = new Documento();
$cpf->setNumero("25650599068");
var_dump($cpf->getNumero());
var_dump(Documento::validarCPF("25650599068")); // retorna true

////////////////

Métodos Mágicos -
Quando tiver algum acontecimento, pode definir algumas açoes pra esse acontecimento. Método construtor é algo que é executado automaticamente quando um objeto é instanciado.
Todos métodos mágicos começarão com __ no nome.
Sempre quando for construir um método construtor, usa o __construct. o construtor é um método mágico.

class Endereco {
    private $logradouro;
    private $numero;
    private $cidade;
    // queremos que, quando instancie uma classe, possa passar o logradouro e o numero da cidade

    public function __construct($a, $b, $c) { // não necessariamente os parametros do construtor precisam ter o mesmo nome do atributo. aqui, __construct é nosso construtor, nosso método mágico.
        $this->logradouro = $a;
        $this->numero = $b;
        $this->cidade = $c;
    }

    // Assim como temos o construct, temos o destruct. O destruct é chamado quando o objeto é destruido, quando ele é removido da memória, podendo ser quando a pagina chega no fim da execução ou se falar que quer que tire da memória, usando o 'unset'. pode-se usar o destruct quando quiser matar variaveis ou desconectar-se do banco de dados, etc. é bom pra automatizar.
    public function __destruct()
    {
        var_dump("DESTRUIR");
    }

    // temos também outro atributo. quando queremos transformar algo em string basicamente. é o __toString.
    public function __toString() {
        return $this->logradouro.", " .$this->numero." - " .$this->cidade;
    }

}

$meuEndereco = new Endereco("Rua Zeferino", "123", "Rio de Janeiro"); // agora precisamos passar os 3 parametros, ja que temos construtor
var_dump($meuEndereco);
unset($meuEndereco);

///////////////

Encapsulamento - 
é proteger/controlar quem pode ver o que. encapsulamento protege as informações. ele faz diferença na herança, onde uns atributos e métodos serão enxergados apenas na classe que a define, e outros métodos e atributos poderão ter na classe filha.

class Pessoa {
    public $nome = "Conor";
    protected $idade = 35; // somente os herdeiros da classe, as classes filhas, poderão acessar este atributo
    private $senha = "123456";

    public function verDados() {
        echo $this->nome . "<br/>";
        echo $this->idade . "<br/>";
        echo $this->senha . "<br/>";
    }
}

$objeto = new Pessoa();

echo $objeto->nome . "<br/>";
$objeto->verDados(); // como o método 'verDados' é público, todos os dados apareceram.

// public todos podem ver. protected so as filhas podem ver. private somente aquela classe pode ver.

class Pessoa {
    public $nome = "Conor";
    protected $idade = 35; // somente os herdeiros da classe, as classes filhas, poderão acessar este atributo
    private $senha = "123456";

    public function verDados() {
        echo $this->nome . "<br/>";
        echo $this->idade . "<br/>";
        echo $this->senha . "<br/>";
    }
}

class Programador extends Pessoa {
    public function verDados() {
        echo get_class($this) . "<br/>"; // irá mostrar o nome da classe do objeto atual.
        echo $this->nome . "<br/>";
        echo $this->idade . "<br/>";
        echo $this->senha . "<br/>"; // aqui irá dar erro pq senha é privado
    }
}

$objeto = new Programador();

echo $objeto->nome . "<br/>";
$objeto->verDados(); // vai funcionar pq, programador herdou de 'Pessoa' o método 'verDados' q é publico. se fosse private, nao iria funcionar.


///////////////

herança - 
por ex
tudo que for de comum entre diversos tipos de veiculos de locomoçao, como navio, moto, carro, etc, posso ter uma classe base. e dessa vc herda pra fazer classes pra fazer coisas especificas, desde que nao tenham algo tao em comum (que possa ficar em uma classe intermediaria). isso é abstração. uma UML bem feita codifica qualquer objeto.

class Documento {
    private $numero; // um documento sempre vai ter um numero
    public function getNumero() {
        return $this->numero;
    }
    public function setNumero($n) {
        $this->numero = $n;
    }

}

class CPF extends Documento {
    public function validar():bool 
    {
        $numeroCPF = $this->getNumero();
        // Validação do CPF, aqui coloca o codigo de validaçao do cpf.
        return true;
    }
}

$doc = new CPF();

$doc->setNumero("111222333-44");

$doc->validar();

var_dump($doc->validar());

echo "<br/>";

echo $doc->getNumero();

/////////////////

INTERFACE:
Ajuda bastante a organizar o código, pq ele determina padrões, por ex, vou fazer um documento, então ele precisa ter um método de validação do documento, ou um método que vai salvar este documento no banco de dados. Você o obriga a ter um determinado padrão. Determina padrões q voce vai ter que fazer. dentro da interface eu digo quais metodos tal coisa vai ter, quais parametros vai ter e qual o modificador de acesso ou encapsulamento os metodos vai ter. na interface não digo o que faz. a classe q implementar essa interface so vai funcionar quando bater 100% com a interface.

interface Veiculo { // o que um veiculo precisaria ter? vamos escrever aqui alguns dos padrões
    public function acelerar($velocidade);
    public function frear($velocidade);
    public function trocarMarcha($marcha);
} 

class Civic implements Veiculo {
    
}

$carro = new Civic(); // se eu rodar somente isto, verá q dará erro, pois irá mostrar que os métodos declarados na interface Veiculo, precisam ser declarados na classe Civic tbm, pq ela implementa a interface Veiculo.

// VEJA AGORA:

interface Veiculo { // o que um veiculo precisaria ter? vamos escrever aqui alguns dos padrões
    public function acelerar($velocidade);
    public function frear($velocidade);
    public function trocarMarcha($marcha);
} 

class Civic implements Veiculo {
    public function acelerar($velocidade)
    {
        echo "O veículo acelerou até " . $velocidade . "km/h";
    }

    protected function frear($velocidade)
    {
        echo "O veículo freou até " . $velocidade . "km/h";
    }

    public function trocarMarcha($marcha)
    {
        echo "O veículo engatou a marcha " .$marcha;
    }
}

$carro = new Civic();
$carro->acelerar(150);
echo "<br/>";
$carro->trocarMarcha(1);
echo "<br>";

// util ate pra integraçao de apis, isto é, pra codigos de terceiros.

// ---------> A DIFERENÇA ENTRE INTERFACE E CLASSE ABSTRATA: uma classe pode implementar várias interfaces.

////////////
CLASSE ABSTRATA-
A diferença aqui e a da interface, tbm, é q nao apenas definimos os métodos que precisamos ter, mas tbm oq eles fazem. uma diferença de classe abstrata pra classe comum é que o objeto nunca vai instanciar uma classe abstrata. crio uma classe, q vai ser abstrata, etals, e, pra usá-la, crio OUTRA classe que vai extender dessa classe abstrata e vai respeitar as definições.

interface Veiculo { // o que um veiculo precisaria ter? vamos escrever aqui alguns dos padrões
    public function acelerar($velocidade);
    public function frear($velocidade);
    public function trocarMarcha($marcha);
} 

abstract class Automovel implements Veiculo { // qq automóvel implementa a interface Veículo, precisa ter esses metodos com esses atributos.
    public function acelerar($velocidade)
    {
        echo "O veículo acelerou até " . $velocidade . "km/h";
    }

    protected function frear($velocidade)
    {
        echo "O veículo freou até " . $velocidade . "km/h";
    }

    public function trocarMarcha($marcha)
    {
        echo "O veículo engatou a marcha " .$marcha;
    }
}

class DelRey extends Automovel {
    // aqui a classe DelRey pode ter suas coisas especificas, de seu veiculo.
    public function empurrar() {

    }
}

$carro = new DelRey(); // daí não posso instanciar um objeto direto da classe abstrata Automovel.
$carro->acelerar(200);

// uma classe vai herdar somente de uma classe abstrata, mas uma classe pode implementar várias interfaces

///////////////

Polimorfismo - classes com o mesmo nome possuem comportamentos diferentes.
abstract class Animal {
    public function falar(){
        return "Som";
    }
    public function mover(){
        return "Anda";
    }
}

class Cachorro extends Animal {
    public function falar() { // houve polimorfismo, mudou o comportamento
        return "Late";
    }
}

// Agora criei outra classe, Passaro.
class Passaro extends Animal {
    public function falar() { // houve polimorfismo, mudou o comportamento
        return "Canta";
    }

    public function mover() {
        return "Voa e " . parent::mover(); // aqui, ele diz: chame o método 'mover' da classe 'Animal', que é a classe pai. vc chama algum metodo da classe pai.
    }
}

class Gato extends Animal {
    public function falar() { // houve polimorfismo, mudou o comportamento
        return "Mia";
    }
}

$pluto = new Cachorro();
echo $pluto->falar() . "<br/>";
echo $pluto->mover() . "<br/>";

$garfield = new Gato();
echo $garfield->falar() . "<br/>";

$ave = new Passaro();
echo $ave->mover();

//////////////

Incluindo classes com AutoLoad -
Digamos por exemplo que seu projeto precise de 4 ou 5 classes, será q precisariamos de require_once para cada uma delas? Aí entra o AutoLoad. É uma função do PHP para que carregue as classes automaticamente sem que use o require. a funçao autoload ficaria em um arquivo e esse arquivo iria como include para cada um dos outros projetos. 

quero simplesmente criar um novo DelRey, instanciar um novo DelRey.

// o autoload so sabe procurar as classes no mesmo diretório.

function incluirClasses($nomeClasse){
    if (file_exists($nomeClasse.".php") === true) {
        require_once($nomeClasse.".php");
    }
}

spl_autoload_register("incluirClasses"); // registra a função 'incluirclasses' como uma função de AutoLoad.
spl_autoload_register(function($nomeClasse){
    if (file_exists("Abstratas". DIRECTORY_SEPARATOR . $nomeClasse.".php") === true) {
        require_once("Abstratas" . DIRECTORY_SEPARATOR . $nomeClasse.".php");
    }
});

$carro = new DelRey(); // quando você cria uma instância de DelRey, o PHP tentará carregar a classe DelRey. Se o arquivo DelRey.php existir no mesmo diretório do script, ele será incluído. Se não existir, o PHP tentará carregar a classe a partir do diretório "Abstratas", se aplicável.

$carro->acelerar(80); // Se a classe DelRey estiver no arquivo DelRey.php no mesmo diretório do script ou no diretório "Abstratas", e se a classe tiver o método acelerar(80), então o código deverá funcionar corretamente.

// /\ Abstratas, em cima, é o nome do diretório em que talvez o arquivo possa estar. 

//////////////////

NameSpace - 
NameSpace permite agrupar as classes dentro de diretórios de uma forma organizada. Aí entra a diferenciação, dividir em espaços diferentes, daí namespace, dar nome para os espaços.

// Devemos dizer onde ele vai procurar as classes.
spl_autoload_register(function($nameClass){
    $dirClass = "class"; // a pasta onde o php deve procurar nossas pastas. nas aulas, essa é o nome da pasta onde tem as classes.
    $filename = $dirclass . DIRECTORY_SEPARATOR . "$nameClass" . ".php";
    if(file_exists($filename)) {
        require_once($filename);
    }
    
});

// Use a constante DIRECTORY_SEPARATOR que o php irá se adaptar pra unix ou windows.

um arquivo cadastro (!!!! lembrando que o nome da classe SEMPRE deve ser igual ao nome do arquivo):
class Cadastro {
    private $nome;
    private $email;
    private $senha;

    public function getNome():string 
    {
        return $this->nome;
    }

    public function getEmail():string 
    {
        return $this->email;
    }

    public function getSenha():string 
    {
        return $this->senha;
    }

    public function setNome($nome)
    {
        $this->$nome = $nome;
    }

    public function setEmail($email)
    {
        $this->$email = $email;
    }

    public function setSenha($senha)
    {
        $this->$senha = $senha;
    }

    public function __toString() {
        return json_encode(array(
            "nome"=>$this->getNome(),
            "email"=>$this->getEmail(),
            "senha"=>$this->getSenha(),
        ));
    }

}

dentro de uma pasta chamada 'namespace', criamos um arquivo, chamado index.php.
abramos o index.php, e digitemos:
require_once("config.php");

$cad = new Cadastro();

$cad->setNome("Luiz");
$cad->setEmail("luiz@hcode.com");
$cad->setSenha("12345");

echo $cad; // o 'echo' não consegue mostrar um objeto, só mostra texto. mas o objeto sabe virar string, q é o __toString.

// digamos que eu tivesse uma subpasta cliente e dentro dela eu tivesse uma outra pasta q seria o cadastro desse cliente, pq vc pode ter cadastro de cliente, de fornecedor, de funcionario, de instrutor... criemos um namespace apenas para o cadastro do cliente.
criemos uma pasta 'cliente' dentro da pasta 'class', e dentro dessa pasta cliente teremos o cadastro de um cliente. criemos o arquivo dentro 'Cadastro.php'.
class Cadastro extends {
    public function registrarVenda() {
        echo "Foi registrada uma venda para o cliente " .$this->getNome(); // da onde vem esse getNome? ela tem que herdar do Cadastro Principal. essa classe, precisamos informar que ela está em um nameSpace. devemos entao informar o namespace desse arquivo.
    }
}
\/

namespace Cliente;
use 
class Cadastro extends \Cadastro{ // volta na raiz e lá acha a classe Cadastro
    public function registrarVenda() {
        echo "Foi registrada uma venda para o cliente " .$this->getNome(); // da onde vem esse getNome? ela tem que herdar do Cadastro Principal. essa classe, precisamos informar que ela está em um nameSpace. devemos entao informar o namespace desse arquivo. colocamos de nome "Cliente"
    }
}

agora, no arquivo index.php
// Precisamos usar a classe do NameSpace, pra usar um nameSpace, uso a palavra-chave "use":
use Cliente\Cadastro; // NAMESPACE\CLASSE -> quero usar o namespace 'Cliente' e a classe 'Cadastro', então, agora, no index.php, ao ver o "$cad = new Cadastro(); ", o Cadastro será o cadastro que está dentro de Cliente.

o cadastro que tá dentro do namespace Cliente' é diferente do cadastro que tá na raiz de class. o cadastro do cliente precisa compartilhar informações com qualquer tipo de cadastro, então extende da classe raiz. 

/////////////////////////

[CONTINUAÇÃO DO QUE TENHO EM CS]
No bind_param, tem q ser passado parametro por referencia, ou seja, devemos criar uma variável, colocar o valor nessa variável, que vai alocar em alguma memória e ai manda a referencia dessa variavel. Por isso, colocamos $login e $senha.

$stmt = $conn->prepare("INSERT INTO tb_usuarios (deslogin, dessenha) VALUES (?, ?)");
$stmt->bind_param("ss", $login, $pass);
$login = "user";
$pass = "12345";

/\ estamos chamando e depois definindo variavel? isso pode, sim, pois aqui tudo isso é o statement prepare, ele vai preparar o comando numa variavel, só sera executado qd o metodo 'execute()' será chamado.

ao executar o arquivo, verá que vai inserir os dados no banco de dados.

com o statement, se vc quiser inserir outro usuario, basta ir no $stmt, jogar outro login e senha, e chamar o 'stmt->execute()' novamente.

---- mas e se eu quiser selecionar e mostrar na tela, q venha do banco de dados? temos o comando fetch.

vamos fazer agora sem o prepare, vamos executar um comando direto no banco de dados. temos que usar a variavel conn da conexão, usar o método query e passar um comando qualquer sql.

$conn = new mysqli("localhost", "root", "", "dbphp7");

if($conn->connect_error) {
    echo "Error: " . $conn->connect_error;
}

$result = $conn->query("SELECT * FROM tb_usuarios ORDER BY deslogin"); // executei a query e guardei o resultado em uma variavel chamada 'result'.

// e como acessar os dados que tão nessa variavel $result? precisamos acessar a variavel e verificar se tem algum dado dentro dela.

while($row = $result->fetch_array()) { // a linguagem SQL tem um cursor, esse cursor tem dados, então vamos verificar linha por linha se tem algum dado dentro do cursor. pra pegar a 1 linha e ver se tem algum dado dentro do cursor, executamos o método fetch_array(). nessa linha de codigo, se tiver esses dados, ele pega e joga no atributo $row. se não tiver, ele chega no EOF (end of file), e retorna um array vazio q equivale a false.

var_dump($row);

}

/\ ao executar, verá que terá arrays. veja que ele traz array com chaves de tanto com indices numericos quanto com indices de nomes. se eu quiser trazer só os nomes, e não os numeros, passa uma constante pre-definida:
while($row = $result->fetch_array(MYSQLI_ASSOC)) { 

    var_dump($row);
    
}

/\ mostrará so indices de nomes.

OU

while($row = $result->fetch_assoc()) { 

    var_dump($row);
 
}


/\ ----!!!!!!!!!!! fetch_assoc é associative array, traz so o nome string do indice. tem tbm so os indices numericos, etc.

e como converter pra JSON se quiser levar pra outra aplicação?
basta criar uma variavel e dizer q é um array, e dentro do while, eu tenho meus dados, dados associativos.


$data = array();
while($row = $result->fetch_assoc()) { 
    array_push($data, $row); // no meu array $data, vou adicionar o $row. ou seja, vou ter um array de arrays.
    var_dump($row);
}

echo json_encode($data);

//////////////////////////////

PDO - 
abrindo a conexão:
$conn = new PDO("mysql:dbname=dbphp7;host=localhost", "root", "senha"); // dentro dos parenteses vamos passar uma string. com quem vamos conversar. primeiro queremos conversar com o mysql. se eu fosse conversar com o sql server eu iria colocar outro tipo de banco. é um padrão chamado DSN, padrão de conexão com o banco de dados.  temos que colocar o nome do banco e o servidor, nas aspas. host é o servidor, com quem eu quero me conectar. os proximos 2 parametros é o login e senha.

COM PDO, podemos trabalhar direto com transações.

$stmt = $conn->prepare("SELECT * FROM tb_usuarios ORDER BY deslogin");

$stmt->execute();

$results = $stmt->fetchAll(PDO::FETCH_ASSOC); // o fetchall vai fatiar TODAS as linhas, diferente do mysqli q tinha q fazer um while passando linha por linha, jogando na linha do row, etc. joguei o resultado em $result, que ja vai ta armazenado todos os resultados. colocamos PDO::FETCH_ASSOC, vai trazer apenas o indice associativo (chave em nome).

var_dump($results);

// e como faz pra navegar por esse ai? se fizesse json_Encode ja tava em json e diminuiria o codigo. mas se quiser percorrer, navegar, mudar algo, pode usarr um foreach.

foreach($result as $row)
{
    // pra pegar o key e value:
    foreach($row as $key => $value) { // o $key é o nome da coluna, e o $value é o valor lá dentro
        echo "<strong>".$key."</strong>".$value."<br/>";
    }
    
}

/////////////////

Conectar PHP 7 ao SQL Server:
$conn = NEW PDO("sqlsrv:database=dbphp7;server=localhost\SQLEXPRESS;ConnectionPooling=0", "root", ""); // mudando em comparaçao ao MYSQL do PDO. connectionpooling na maioria das vezes vai ser 0, a menos q vc queira manter o estado de conexão aberta. depois vem login e senha.


//////////////

PDO: Inserindo dados no banco - 
$conn = new PDO("mysql:host=localhost; dbname=dbphp7", "root", "senha"); 

// agora, prepara a query
$stmt = $conn->prepare("INSERT INTO tb_usuarios (deslogin, dessenha) VALUES(:LOGIN, :SENHA)");  // agora, colocamos :UMIDENTIFICADOR, pra segurança.

$login="jose";
$password = "1234567890";

$stmt->bindParam(":LOGIN", $login); // usamos bindParam para cada parametro que a gente tem, na ordem q colocamos. como colocamos :login e :senha, o bindParam tem q ser nessa ordem. 
// temos q fazer isso para quantos parametros tivermos, como temos 2, vms fazer o da senha agora.
$stmt->bindParam(":SENHA", $password);

$stmt->execute();

echo "Inserido OK";

//////////////

Alterando dados no banco - 
Agora, no prepare, em vez de inserir um dado vou estar apenas alterando um registro ja existente.
$conn = new PDO("mysql:host=localhost; dbname=dbphp7", "root", "senha"); 

// agora, prepara a query
$stmt = $conn->prepare("UPDATE tb_usuarios SET deslogin = :LOGIN, dessenha = :PASSWORD where idusuario = :ID");  // no insert tinha o values, agui vamos pra quando for igual ao :LOGIN e :PASSWORD. temos que criar agora bindParam para o :ID. não esqueça do 'where' pro update.

$login="jose";
$password = "1234567890";
$id = 2;

$stmt->bindParam(":LOGIN", $login); // usamos bindParam para cada parametro que a gente tem, na ordem q colocamos. como colocamos :login e :senha, o bindParam tem q ser nessa ordem. 
// temos q fazer isso para quantos parametros tivermos, como temos 2, vms fazer o da senha agora.
$stmt->bindParam(":SENHA", $password);
$stmt->bindParam(":ID", $id)

$stmt->execute();

echo "Inserido OK";

////////////////

Apagando dados no banco - 

$conn = new PDO("mysql:host=localhost; dbname=dbphp7", "root", "senha"); 

// agora, prepara a query
$stmt = $conn->prepare("DELETE FROM tb_usuarios WHERE IDUSUARIOS = :ID");  

$login="jose";
$password = "1234567890";
$id = 2;

$stmt->bindParam(":LOGIN", $login); 
$stmt->bindParam(":SENHA", $password);
$stmt->bindParam(":ID", $id)

$stmt->execute();

/\ delete exclui DADOS, use sempre o WHERE.

/////////////

PDO- Executando transações -
Restaurar backup é um processo danoso. E se eu pudesse controlar o update, tipo, se eu tivesse ctrl+z? com banco de dados, isso é transação. tenho COMMIT pra confirmar ou ROLLBACK pra cancelar. 
por ex: 
antes de iniciarmos o statement, vamos iniciar a transação. e a transação tá amarrada a conexao, e não ao statement. 

$conn = new PDO("mysql:host=localhost; dbname=dbphp7", "root", "senha"); 

$conn = beginTransaction(); // iniciou a transação

// agora, prepara a query
$stmt = $conn->prepare("DELETE FROM tb_usuarios WHERE IDUSUARIOS = ?");  

$login="jose";
$password = "1234567890";
$id = 2;

$stmt->execute(array($id)); // aqui, em vez de usar bindParam no parametro, aqui no execute, passo um array. a primeira ? que encontrar, vai ser o primeiro indice do array.

$conn->rollback(); // com isso, agora não irá realmente deletar o registro no caso onde tiver $id = 2, por causa do rollback.

// Se fizermos commit, ele iria fazer:
$conn->commit(); // agora ta confirmado, vai executar normal o comando.

/////////////

PDO - DAO -
em vez de fazer o php conversar direto com o banco, ele passa pelas classes que tratam direto com essa informação.
aqui vamos aprender a tratar com essas classes que vão direto pro banco.

criamos repositorio no github
criamos pasta 'pdo' no htdocs, abrimos o git bash lá. executamos:
git init
git remote add origin LINKDOREPOSITORIO
git pull origin master // pegar tudo que tem la, mas tem nada lá no repositorio.

arquivo php Sql.php
class Sql extends PDO { // classe sql (podia ser o nome q eu quiser) extendendo da classe NATIVA DO PHP: PDO
    private $conn; // tenho o atributo $conn no escopo da minha classe.

    public function __construct() 
    { // construtor para quando eu criar um objeto dessa classe Sql, ela conecte automaticamente ao banco de dados. outra maneira pra conectar: eu poderia colocar como parametros no metodo construtor tbm, e quando eu chamasse a classe new Sql, eu já passaria os parametros para conectar.

        $this->conn = new PDO("mysql:host=localhost;dbname=dbphp7", "root", "senha"); 
    }

    // /\ isso ja é suficiente pra eu entrar no banco. mas, como executo um comando lá? tem aquele prepare, bindparam, execute, etc. pra isso, faremos:

    public function runQuery($RawQuery, $params = array()) { // $rawQuery significa uma query bruta, uma query que vamos tratar depois. e vamos receber os parametros, q posso falar por PADRÃO que será nosso array, pq serão nossos dados.

        $stmt = $this->conn->prepare($RawQuery); // criei meu statement, q é uma variavel mesmo, nao tem this, so funciona dentro desse metodo. como eh classe extendida, temos acesso ao 'prepare'. 

        // agora vou associar meus parametros ao comando. como? com foreach.

        foreach ($params as $key => $value) { // aqui faço foreach dos meus parametros, vou pegar a chave e o valor.

            $stmt->bindParam($key, $value); // lembra que fazíamos vários bindParam? aq faço dentro do foreach, pra deixar dinamico.
        
        }
    }

    // mas e se eu tiver outros métodos que também vão precisar fazer isso dentro do query? em vez de deixar dentro do query, posso fazer um para chamar aqui o bindParam, ou setparams, algo assim. posso criar outro método e reutilizar o codigo depois. tiro o Foreach do método 'runquery' e jogo em um outro, pode ser 'setparams' e troco o nome das variáveis.

    private function setParams($statment, $parameters = array()) {

       foreach ($parameters as $key => $value) { 

            $this->setParam($key, $value); 
        
        }
    }

    // Agora vamos externar, e fazer um bind de um parametro só:
    private function setParam($statment, $key, $value) {
        $statment->bindParam($key, $value);
    }
}

// Agora na função runquery, agora consigo chamar o setParams, q ele vai saber como fazer o set de cada um dos parametros. 
public function runQuery($RawQuery, $params = array()) { 

    $stmt = $this->conn->prepare($RawQuery);

    $this->setParams($stmt, $params);

    $stmt->execute();

    return $stmt; // precisamos executar, agr fazemos so um retorno com o execute.
}

// agora um método pro select:
public function select($rawQuery, $params = array()):array (espera retorno array, fica seguro e organizado)
{
    $stmt = $this->runQuery($rawQuery, $params);
    return $stmt->fetchAll(PDO::FETCH_ASSOC); // pra ver somente os dados associativos, sem indices, apenas o de nome. aqui seria meu $result, no retorno.
}
// agora precisamos apenas fazer o fetch disso tudo aqui.

// agora criemos outro arquivo chamado config.php, na mesma pasta onde ta o sql.php:
criemos autoload:
spl_autoload_register(function($class_name){
    $filename = $class_name.".php";
    if(file_exists($filename)) {
        require_once($filename);
    }
});

// Agora vamos criar outro arquivo chamado index.php
<?php

require_once("config.php");
$sql = new Sql(); // ele sabe encontrar a classe, encontraar a classe Sql que tá lá em sql.php
$usuarios = $sql->$sql->select("SELECT * FROM tb_usuarios"); // achando sql, já posso jogar o comando no banco de dados. o retorno jogo tudo na variavel $usuarios. fui no método select.
echo json_encode($usuarios); 

?>

//////////////////////

PDO - DAO - SELECT
Agr vamos fazer a classe Sql que criamos conversar com outra classe.
no arquivo config.php, vamos colocar que começa na pasta "class", directory separator, e nome do arquivo. isso tudo no filename, q é lá nessa pasta onde fica as classes. joguei lá então o 'sql.php'.
vamos adicionar tudo no repositorio:
no git bash na pasta 'dao', digitemos:
git add --all
git commit -m "Iniciamos o projeto"
git push origin master

criemos arquivo Usuario.php
class Usuario {
    private $idusuario;
    private $deslogin;
    private $dessenha;
    private $dtcadastro;

    public function getIdusuario() {
        return $this->idusuario;
    }

    public function setIdusuario($value) {
        $this->idusuario = $value;
    }

    public function getDeslogin() {
        return $this->deslogin;
    }

    public function setDeslogin($value) {
        $this->deslogin = $value;
    }

    public function getDessenha() {
        return $this->dessenha;
    }

    public function setDessenha($value) {
        $this->dessenha = $value;
    }

    public function getDtcadastro() {
        return $this->dtcadastro;
    }

    public function setDtcadastro($value) {
        $this->dtcadastro = $value;
    }

    public function loadById($id) {
        $sql = new Sql();

        $results = $sql->select("SELECT * FROM tb_usuarios WHERE idusuario = :ID", array(
            ":ID"=>$id
        )); // chamando o método 'select'. select pelo id do usuario, o id do usuario é chave primaria, ou seja, vai me retornar uma linha só. podemos colocar o :ID, é a identificaçao, so tem q ser igualzinho. coloquei um array, que são os nosssos parametros, que colocamos dentro da nossa classe 'sql' no método 'select' lá. ":ID"=>$id é basicamente chave=>valor. :ID é a identificação do parametro. o valor dele é minha variavel $id que to aqui recebendo no meu método. :ID terá o valor que $id tem.

        // so precisamos validar isso, se tivermos so 2 registros no banco e ta passando id 99? nao vai ter id 99. vamos fazer um if.
        if(isset($results[0]) ) ou if(count($results) > 0) {

            $row = $results[0]; // como é array de array, pega na posição 0. pega a primeira linha ou a unica linha. aqui estou atribuindo à variável $row a primeira linha de resultados obtida da consulta, ou seja, o primeiro elemento do array $results. comum fazer isso quando é o caso de buscar um usuario pelo id, isto é, consulta por uma chave primaria unica.

            $this->setIdusuario($row['idusuario']);
            $this->setDeslogin($row['deslogin']);
            $this->setDessenha($row['dessenha']);
            $this->setDtcadastro(new DateTime($row['dtcadastro'])); // fizemos new DateTime pra ficar no formato que é igual do banco de dados

        }
    }
}

// agora os atributos já estão preenchidos com as informações que vieram do banco. perceba que no metodo 'loadbyId' nao tem retorno, ele nao ta devolvendo nada pra tela. so alimentamos os atributos, carregamos dados do banco pro objeto. aprendemos o __ToString, q qd dá echo no objeto, ele executa o que ta dentro do __ToString.

public function __toString() {
    return json_encode(array(
        "idusuario"=>$this->getIdusuario(),
        "deslogin"=>$this->getDeslogin(),
        "dessenha"=>$this->getDessenha(),
        "dtcadastro"=>$this->getDtcadastro()->format("d/m/Y H:i:s"); // o objeto date time tem o metodo format pra formatar do jeito que eu quero.
    ));
}

////////////////

PDO - DAO - LIST -
Aprenderemos mais sobre listar dados, em vez de passar um parametro e buscar por um usuario determinado, eu posso buscar todos os usuarios de uma determinada tabela ou por alguma condição.

quero trazer uma lista com todos os usuarios q estão na tabela:
 
public static function getList() {
    $sql = new Sql();

    return $sql->select("SELECT * FROM tb_usuarios ORDER BY deslogin");
}

o LoadById traz o usuario daquele Id. o getList pegará uma lista de usuários. fizemos getList como metodo static, ja que nao precisamos usar $this no metodo. pq? pq quando usamos this vc ta pegando atributos da classe, vc ta amarrando o método à classe, quando vc nao usa $this, o metodo pode ser usado fora ou dentro da classe, ou seja, static.

// agora, faremos pra buscar um usuario:
public static function search($login) {
    $sql = new Sql();

    return $sql->select("SELECT * FROM tb_usuarios where deslogin LIKE :SEARCH ORDER BY deslogin", array( 
        ':SEARCH'=>"%".$login."%" // aqui, ele vai pegar o que eu digitar dentro de $login, colocar a % antes e depois, e quando eu for enviar pro nosso parametro q foi preparado, vai evitar o SQL injection.
    )); // ':SEACH' é o identificador

}

// no index.php
$search = Usuarios::search("ro");
echo json_encode($search);

// vai mostrar a linha de codigo que tem 'root' pq é onde tem 'ro'.
// agora vamos obter os dados do usuario autenticado. vamos ter que passar o login e a senha, tem q ser corretos, e ai vai carregar os dados do usuario. nesse caso, como vamos usar o get e set, no contexto do objeto, nao pode ser static, ja q vamos amarrar bastante a classe.

public function login($login, $password) {
    $sql = new Sql();
    $results = $sql->select("SELECT * FROM tb_usuarios WHERE deslogin = :LOGIN AND dessenha = :PASSWORD", array(
        ":LOGIN"=>$login,
        ":PASSWORD"=>$password
    ));

    if(count($results) > 0) {

        $row = $results[0]; // como é array de array, pega na posição 0. pega a primeira linha ou a unica linha

        $this->setIdusuario($row['idusuario']);
        $this->setDeslogin($row['deslogin']);
        $this->setDessenha($row['dessenha']);
        $this->setDtcadastro(new DateTime($row['dtcadastro']));
    }
    else {
        throw new Exception("Login e/ou Senha inválidos.");
    }
}

no index.php :
//carrega um usuário usando o login e a senha
$usuario = new Usuario();
$usuario->login("root", "12345");

echo $usuario;

///////////////

PDO - DAO - INSERT:

// vamos criar um método para setar os dados, ja que estamos usando varias vezes.

public function setData($data) {
    $this->setIdusuario($data['idusuario']);
    $this->setDeslogin($data['deslogin']);
    $this->setDessenha($data['dessenha']);
    $this->setDtcadastro(new DateTime($data['dtcadastro']));
}

agora, vai lá no login e coloca:
$row = $results[0];
$this->setData($results[0]);

e onde tiver os dados de setData, substitui por: $this->setData($results[0]);

public function insert() {
    $sql = new Sql();

    $results = $sql->select("CALL sp_usuarios_insert(:LOGIN, :PASSWORD)", array(
        ':LOGIN'=>$this->getDeslogin(),
        ':PASSWORD'=>$this->getDessenha()
    )); // como estamos usando o mysql, a procedure usamos 'CALL'. vamos ter que criar uma procedure no banco de dados.

    if(count($results[0]) > 0) {
        $this->setData($results[0]);
    }

}

// no Banco de dados:

create procedure sp_usuarios_insert (pdeslogin varchar(64), pdessenha varchar(256)) begin insert into tb_usuarios (deslogin, dessenha) values (pdeslogin, pdessenha); select * from tb_usuarios where idusuario = LAST_INSERT_ID(); END$$ // O LAST_INSERT_ID é o ultimo ID inserido que usou uma coluna AUTO_INCREMENT, funçao nativa do mysql.
 
// o 'p' na frente é pra diferenciar dos nomes do campo. oq começa com 'v' é variavel, 'p' é um parametro. pdeslogin e pdessenha é o parametro que enviei. ou por ex vidusuario é a variavel q to usando pra armazenar. com este comando acima, criamos um procedimento. 

// no index.php
$aluno = new Usuario();

$aluno->setDeslogin("aluno");
$aluno->setDessenha("@alun0");

$aluno->insert(); 

echo $aluno;
// não temos o id e data de castro, mas o insert vai trazer, pq ta fazendo via procedure.

poderia deixar mais facil ainda construindo construtor no 'Usuario.php':
public function __construct($login = "", $password = "") { // colocando = "" ele aceita mesmo que tenha nada, se tiver nada ele joga como nada
    $this->setDeslogin($login);
    $this->setDessenha($password);
} 

em aluno.php
$aluno = new Usuario("aluno", "@alun0");
$aluno->insert();
echo $aluno;

//////////////

PDO - DAO - DELETE -

no Usuario.php:
public function delete() {
    $sql = new Sql();

    $sql->query("DELETE FROM tb_usuarios WHERE idusuario = :ID", array(
        ":ID"=>$this->getIdusuario()
    )); // vamos passar nosso id nos parametros...

    // Depois que apaga, vamos refletir no banco

    $this->setIdusuario(0);
    $this->setDeslogin("");
    $this->setDessenha("");
    $this->setDtcadastro(new DateTime());
    // /\ botando tudo sem valor, limpando as propriedades do objeto apos a exclusão.

}

//////////////

MANIPULANDO ARQUIVOS -
Gerenciamento de arquivos -
é poder criar, gerenciar, mover, pastas e diretorios e arquivos fisicos. entao posso usar o servidor onde ta rodando meu php como um repositorio. hoje vamos ver com diretorio/pasta.

o primeiro arquivo irá verificar se o diretorio existe. se não existir, criaremos o diretório. 

$name = "images"; // é o nome de um diretorio de imagens, por ex
// como verifico se o diretorio existe ou não? existe uma função chamada 'is_dir'
if(!is_dir($name)) { // se o nome de tal variavel não for um diretorio.
    mkdir($name); // cria um diretorio com esse nome de $name.
    echo "Diretorio $name criado com sucesso";
}
else {
    rmdir($name); // aqui, ele vai remover
    echo 'Diretório já existente: ' .$name. ' e foi removido. ';
}

// e se precisarmos ler os arquivos dentro de um diretorio especifico? pra pedir pro php ler nao so um arquivo/diretorio especifico, mas tudo que há dentro dele. a ideia aqui agora é usar uma funçao chamada 'scandir'

em outro arquivo já:
<?php

$images = scandir("images"); // o diretorio 'images' tem que existir
var_dump($images);

$data = array();

foreach($images as $img) {
    if(!in_array($img, array(".", ".."))) 
    { // a função in_array precisa do neddle e do haystack. o neddle é onde que voce ta procurando, quem é o alvo que voce quer que procure. o haystack sao as opçoes mesmo, é um array. mas o que a gente quer é não achar esses caras, por isso o '!'. entendamos o in_array: ele faz uma busca dentro de um array. no caso, se não existir '.' nem '..' no array, ai me interessaria. 

        $filename = "images" . DIRECTORY_SEPARATOR . $img; // concatenando com o nome do arquivo, q é $img

        $info = pathinfo($filename);

        var_dump($info);

        array_push($data, $info);
    }
}

echo json_encode($data);

// podemos juntar toda essa informação de cima em uma variavel e converter em JSON, por isso criei o array $data la em cima, 'data' de dados.

// e se eu quiser ver, por ex, o tamanho do meu arquivo? dentro da variavel $info, vou criar uma chave de nome 'size' que vai pegar o tamanho do arquivo. vou botar a data de modificação do arquivo tbm.

foreach($images as $img) {
    if(!in_array($img, array(".", ".."))) 
    { // a função in_array precisa do neddle e do haystack. o neddle é onde que voce ta procurando, quem é o alvo que voce quer que procure. o haystack sao as opçoes mesmo, é um array. mas o que a gente quer é não achar esses caras, por isso o '!'. entendamos o in_array: ele faz uma busca dentro de um array. no caso, se não existir '.' nem '..' no array, ai me interessaria. 

        $filename = "images" . DIRECTORY_SEPARATOR . $img; // concatenando com o nome do arquivo, q é $img

        $info = pathinfo($filename);

        $info["size"] = filesize($filename); // mostra o tamanho em bytes.

        $info["modified"] = date("d/m/Y H:i:s", filemtime($filename));

        $info["url"] = "http://localhost/arquivos/".str_replace("\\", "/"), ($filename); // como tamo sando DIRECTORY_SEPARATOR, a barra fica ao contrario se nao colocar str_replace. tem q colocar \\ pq é a barra que quero inverter, e é um escape, pela barra que quero trocar.
        
        var_dump($info);

        array_push($data, $info);
    }
}

?>

//////////////////

criar arquivos com fopen() 

$file = fopen("log.txt", "w+"); // a função fopen() te pede 2 parametros, o primeiro é o caminho do arquivo, qual o endereço do arquivo? o segundo é como voce quer controlar esse arquivo? ler, alterar? conteudo que tiver nele, quer q seja removido ou alimentar? vamos criar o arquivo 'log.txt' e o w+ é que voce vai escrever dentro do arquivo, e o + é com leitura, entao, vai abrir o arquivo para leitura e escrita. por isso a variavel $file, nesse momento, é um resource, q faz referencia a um arquivo certo.

fwrite($file, date("Y-m-d H:i:s") . "\r\n"); // o primeiro parametro q espera é um resource, isto é, qual o arquivo/manipulador que estou usando. e o segundo parametro são os dados que quero colocar dentro do arquivo.

// agora, precisamos liberar da memoria, fechar o manipulador, q tbm espera um resource, um arquivo/manipulador.
fclose($file);

echo "Arquivo criado com sucesso";

// interessante que isso fica no servidor. não fica no pc do usuario, então posso controlar qualquer informaçao que eu quiser. obs: pra pular dentro desse arquivo, é \r e \n. \r é de retorno e \n pra nova linha. \t é tabulaçao.

// se fosse a+, o conteudo será preservado, o ponteiro movido pro final do arquivo. e vai ser adicionado a nova data no final.

// como converter os dados direto do BD em um CSV?
criei um arquivo bd.php na pasta de arquivos. puxei o config.php e a pasta class do DAO.
<?php

require_once("config.php");

$sql = new Sql();

$usuarios = $sql->select("SELECT * FROM tb_usuarios ORDER BY deslogin");

print_r($usuarios);

?>
// eai, ao ver, como converter isso em csv? 
arquivo csv é um arquivo formatado. cada coluna eh um tipo de info, assim como no BD. e ai, normalmente ficam separadas por virgula. e ai vao respeitar essa ordem. o separador normalmente é a virgula, sempre q quebra a virgula é outro registro.

// criemos outro arquivo csv na pasta. mas antes, precisamos criar um header no arquivo bd.php
no arquivo bd.php:
require_once("config.php");

$sql = new Sql();

$usuarios = $sql->select("SELECT * FROM tb_usuarios ORDER BY deslogin");

print_r($usuarios);

$headers = array(); 

foreach($usuarios[0] as $key => $value) {
    array_push($headers, ucfirst($key));
} // foreach na primeira linha dos dados dos nossos usuarios, e entao fiz foreach pra passar coluna por coluna, vai ter o numero da coluna, a chave (key) e o valor. e botamos ucfirst($key) pra deixar a primeira letra como maiuscula.

echo implode(",", $headers); // implode é transformar array em string, e o separador vai ser a virgula.

// pq colocamos em array? vamos ter q colocar o separador q é a vírgula. pra isso, vamos usar agora o implode.
echo implode(",", $headers); // implode é transformar array em string, e o separador vai ser a virgula.


-------> // vamos pros dados agora, o cabeçalho ta pronto, vamos colocar dentro do nosso arquivo de usuarios csv.
no arquivo bd.php:
require_once("config.php");

$sql = new Sql();

$usuarios = $sql->select("SELECT * FROM tb_usuarios ORDER BY deslogin");

print_r($usuarios);

$headers = array(); 

foreach($usuarios[0] as $key => $value) {
    array_push($headers, ucfirst($key));
} 

$file = fopen("usuarios.csv", "w+"); // se nao existir, será criado.

fwrite($file, implode(", ", $headers)); // coloquei o implode aqui agora, q é o que eu vou escrever dentro do arquivo.

// vamos alimentar os dados.

foreach($usuarios as $row) { // AQUI É UM FOREACH NAS LINHAS!!!!!!!!! 
    // mas, lembre que precisamos juntar os dados por linha?  
    $data = array(); 
    // agora vamos criar um foreach para descobrirmos cada um dos dados, cada uma das linhas
    foreach($row as $key => $value) { // AQUI É UM FOREACH NOS CAMPOS!!!!!! Quando entra na primeira linha ele faz as colunas. na segunda linha, as outras colunas
        array_push($data, $value);
    }

    fwrite($file, implode(", ", $data) . "\r\n");
}
// /\ pra cada linha que eu tiver no meu banco de dados, se eu tiver 5 registros, ele vai rodar 5 vezes. ele vai pegar o nome dessas informaçoes e vai jogar dentro da variavel data. fizemos array dentro de outro array pq estamos trabalhando com PDO, e no statement prepare ele traz um array dentro de outro.

fclose($file); // não se esqueça de fechar o arquivo ao final.

///////////////

Excluindo arquivos -
Num novo arquivo -
$file = fopen("teste.txt", "w+"); // o primeiro parametro  é o nome do arquivo. o segundo é oq fazer.

fclose($file);

unlink("teste.txt"); // obs: $file é a variável resource. ela tá apontando pro arquivo no modulo que voce abriu e no ponteiro que voce criou. unlink serve para excluir/remover um arquivo do sistema de arquivos.

echo "Arquivo removido com sucesso.";

dentro de um outro arquivo.
if (!is_dir("images")) mkdir(images);

foreach(scandir("images") as $item) {
    if(!in_array($item, array(".", ".."))) {
        unlink("images/" . $item); // $item nome do nosso arquivo q ele encontrou a partir do scandir.
    }
}
/\ com isso, ele vai apagar um diretorio inteiro. scandir vai ler todo o diretorio. obs: so vai permitir excluir arquivos que tenham a mesma permissao que o servidor web tem.

/////////////////

Lendo conteúdo de arquivos -
fgets -> fread x fgets, o fgets lê linha por linha do arquivo. o fread tem q passar quantos bytes quer ler do arquivo. 350 bytes = 350 caracteres.

num novo arquivo:

$filename = "usuarios.csv";

if(files_exists($filename)) {
    $file = fopen($filename, "r");

    $headers = explode(",", fgets($file)); // usei explode pra transformar em array.

    var_dump($headers);
}

// blz, fgets pega a 1o linha, mas agora ele ta na 2 linha, como faço pra rodar tudo? criemos while, enquanto tiver linha, ele roda.

if(files_exists($filename)) {
    $file = fopen($filename, "r");

    $headers = explode(",", fgets($file)); // usei explode pra transformar em array.

    $data = array();

    while($row = fgets($file)) { // se retornar algo, continua no while, senao, ele sai do while.
        // basicamente aqui dentro temos que fazer o processo inverso de quando fizemos em csv, isto é, fazer par chave valor.
        $rowData = explode(",", $row);
        $linha = array();

        for($i = 0; $i < count($headers); $i++) {
            $linha[$headers[$i]] = $rowData[$i]; // o 'i' aqui valendo '0' eu estaria pegando a posiçao 0 do headers, e a posiçao 0 do headers é o idusuario (no caso da video-aula).
        }
        // quero adicionar essa variavel linha ao meu data principal, que eles vão ter todos os registros. meu array $linha é um array de chave e valor
        array_push($data, $linha); 
    }  
    fclose($file);
    echo json_encode($data);
}

/\ trazemos um arquivo do csv e botamos no PHP. geramos um json.

---------
Agora, usando uma função diferente file_get_contents. Ela le o arquivo em disco igual o fopen, mas e se fosse uma imagem? Se eu precisar mandar como texto? Ou mandar como API para um lugar? Hoje, tem o Base64, que converte binário em string. Mas tem um formato especifico, qual é? é colocar data:tipo do arquivo precisa informar, q seria o minitype. por ex: png é image.png, jpg é image.jpg.

Em um novo arquivo:
$filename = "logo.png"; // é uma imagem q for que eu tenho q ter, com esse nome. pode ser a logo do curso.

$base64 = base64_encode(file_get_contents($filename)); // essa função lê o conteúdo de um arquivo, lê inteiro. basta passar o nome do arquivo, mas ele passa binario, mas quero em string, base64, ai eu uso a função base64_encode.

echo "data: image/png;base64," . $base64;
// /\ vai ver que vai gerar um codigo string base64 grandao, se ao copiar tudo e colar na URL, ele vai abrir a imagem.

// _____> mas vamos criar dinamico pra nao ter que especificar jpg, png, etc. 

$filename = "logo.png"; 

$base64 = base64_encode(file_get_contents($filename)); 

$fileinfo = new finfo(FILEINFO_MIME_TYPE); // funçao finfo é para obter informaçoes sobre o tipo de um arquivo.

$mimetype = $fileinfo->file($filename);

$base64encode = "data:" . $mimetype . " base64," . $base64;

em HTML agora, fora da tag php:
<a href = "<?php=$base64encode?" target="_blank">Link para imagem</a> // n preciso colocar echo base64encode, so ?=$... ja basta
<img src= "<?php=$base64encode?">

/\ binario convertido em texto.

//////////////////////////

Como fazer upload de arquivos -
php faz upload de arquivos para o servidor.
em um novo arquivo:

antes do php mesmo, precisamos de um campo pra selecionar o arquivo a ser enviado.
<form action="" enctype="multipart/form-data"> // o enctype permite que vc coloca o tipo de informaçao que voce está enviando. por padrão, o formulario envia texto/string. mas agr vamos enviar dados por meio do formulario. por isso multipart/form-data, q significa: tudo q tiver dentro da tag form serão enviados como dados binarios. entao sao dados q fogem do padrao string. se não colocar isso, o upload do lado do php nao vai funcionar, não vai entender o arquivo como fisico.

    <input type="file" name="fileUpload">

    <button type="submit">Send</button>


</form>

<?php

if ($_SERVER["REQUEST_METHOD"] === "POST") {  // o método do formulario
// o primeiro passo é recuperar um arquivo que foi enviado lá. quando os dados são enviados via post, usamos $_POST para STRINGS. no caso do arquivo form-data, usamos $_FILES q é outra variavel superglobal usada pra lidar com arquivos que são enviados através de um formulario HTML, mas serve pra tratar especificamente arquivos enviados para upload. como funciona qd vc envia o arquivo de um formulario para um servidor? na hr q selecionar zip, ou imagem, na hr de enviar, o php precisa ter uma pasta temporaria no servidor pra transferencia de pacotes. 

    $file = $_FILES["fileUpload"]; // é um array superglobal, e dentro, vai o nome do meu input type file. como colocamos fileUpload, vai esse mesmo.

    if($file["error"]) {
        throw new Exception("Erro: " . $file["error"]); // o nome do erro ta nesse file error ai.
    }

    // vamos criar um diretorio a parte para receber os meus arquivos, meus uploads. importante ser um diretorio a parte pq ele vai ter permissão de escrita.

    $dirUploads = "uploads";
    // verificaçao direto no php se o diretorio existe, senao existir, criar:
    if(!is_dir($dirUploads)) {
        mkdir($dirUploads); // se colocar uma ',' dá pra por a permissao que a pasta vai ter, igual linux, tipo "650". mas por padrão, se colocar nada, ja tem permissão padrão de ESCRITA.
    }

    // aqui é o upload propriamente dito
    if(move_uploaded_file($file["tmp_name"], $dirUploads . DIRECTORY_SEPARATOR . $file["name"])){ // essa é a função, ela vai receber primeiro o arquivo temporario do seu servidor, e pra onde ele vai, ou até mesmo com qual nome ele vai. se o upload for com sucesso, essa funçao te retorna true, se der erro retorna false. por isso fazemos um if. os parmaetros são filename e destination. move_uploaded_file move do diretorio temporario do servidor para uma pasta que você criou, so tenha certeza se a pasta q voce criou tem a permissão necessaria pra fazer o upload.

        echo "Upload realizado com sucesso!";

    } else {

        throw new Exception("Não foi possivel realizar o upload.", 1);

    }

}

// agora, ao enviar um arquivo, irá criar um diretorio 'uploads' com o arquivo que voce enviou


?>

//////////////

Downloads de arquivos com file_get_contents:
Download via programaçao. como posso passar uma URL de uma determinado arquivo para o PHP, o php entende q é um arquivo e permite q vc reconstrua uma copia dele via programação.

iremos usar uma função que ela PEGA o conteúdo de um arquivo.

em uma pasta chamada 'donwload', criemos um novo arquivo:

<?php

$link = "https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png"; // colocamos o link de imagem qualquer, mas colocamos dentro da variavel so pra facilitar mesmo. 

$content = file_get_contents($link); // é o conteudo da imagem. é o endereço do arquivo.

// precisamos interpretar. vem em conteudo bruto. mas nao ta formatado, nao sabe que é uma imagem. então, vamos usar o parse_url para transformar o que tá vindo pela url em um arquivo real. e vamos guardar na variavel $parse.

$parse = parse_url($link);

//var_dump($parse); // verá que terá o scheme q é https, o host q é www.google.com.br, o path q é o caminho, isto é, tudo depois de /images

pra eu pegar só a parte do 'path', façamos:
$basename = basename($parse["path"]); // nome base da minha variavel parse na chave 'path', q vai trazer o caminho pra gente.

// agora precisamos criar esse arquivo com conteudo dele no disco do servidor. vamos criar com fopen, se ele nao existir, ele cria com aquele sinal de '+', tipo 'w+'.

$file = fopen($basename, "w+"); // guardando dentro da variavel $file. é nessa linha em que to gerando o nome do arquivo.

fwrite($file, $content); // aqui geramos a copia do arquivo (no caso, a imagem), aqui estamos escrevendo no disco rigido.

fclose ($file); // apos escrever o arquivo, boa pratica é fechar
?>

<img src="<?=$basename?>"> // na imagem nao to chamando link, é só o basename, isto é, ta vindo da propria pasta do servidor, a imagem do google q será recriada no diretorio

// /\ ao executar, vera a imagem do google, mas é da propria pasta

//////////////

Movendo um arquivo -
vamos mover um arquivo de um lugar para o outro usando a função 'rename'

$dir1 = "folder_01";
$dir2 = "folder_02";

if(!is_dir()) mkdir($dir1);
if(!is_dir()) mkdir($dir2);

$filename = "README.txt";

if(!file_exists($dir1 . DIRECTORY_SEPARATOR . $filename)) {
    $file = fopen($dir1 . DIRECTORY_SEPARATOR . $filename, "w+");

    fwrite($file, date("Y/m/d H:i:s"));

    fclose($file);
}

rename($dir1 . DIRECTORY_SEPARATOR . $filename, $dir2 . DIRECTORY_SEPARATOR . $filename); // o primeiro parametro é o nome do arquivo original, onde ele ta, e o segundo parametro é pra onde ele vai e com que nome. a forma como nos armazenamos arquivos nos discos são apenas ponteiros, isto é, direção de onde eles estão. aqui nessa linha de comando é: origem, destino

echo "Arquivo movido com sucesso!";

rename então move o arquivo ou permite renomear se continuar na mesma pasta.

///////////////

cURL - 
O cURL solucionou o problema para APIs, antes tinham bibliotecas escritas em todas as linguagens. ex: se o google tinha uma biblioteca para as pessoas, ele tinha q ter em php, pyton, java, etc. se eu quisesse usar o google maps mas usar o ponteiro, usar algumas rotas, mas pra isso eu tinha q ter a versão java, php, etc. pensando nisso, disponibilizou-se rotas API, isto é, Rest API. solicita esse endereço aqui passando esses parametros via get, post ou delete, etc. o cURL resolveu isso, pq a comunicaçao podia ser independente doq for. agora, se tivermos uma API de pagamento, por exemplo, do paypal, eles nos oferecem uma URL e nos devolvem um JSON nesse formato. se precisarem mudar, etc, essa parte final, não vai mudar. continua mesma url, mesmo json. se precisarem mudar, vão mudar internamente. meu sistema conversa com aquela URL e consome as informaçoes naquele formato. 

vamos ver o webservice do ViaCEP, q é gratuito. vamos lá e ver o retorno em JSON.
lá tem o json URL: viacep.com.br/ws/01001000/json/ // aqui, o numero troca-se pelo CEP.

<?php

$cep = "71070520"
$link = "https://viacep.com.br/ws/$cep/json/";

$ch = curl_init($link); // inicializa uma sessão cURL

curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); // primeiro é a biblioteca que a gente iniciou. o segundo parametro é o retorno que a gente espera. o terceiro parametro é se vc quer ou não a resposta de volta, é true ou false (1 ou 0).

curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0); // se não colocar o CURLOPT_SSL_VERIFYPEER, a chamada do cURL não vai funcionar, só iria funcionar se fosse HTTP

// depois das opçoes, agora temos que ter nossa resposta:
$response = curl_exec($ch); 

// agora, temos que fechar/liberar a conexão q já terminamos
curl_close($ch);

//ele veio como JSON de retorno, agora queremos q volte como array:
$data = json_decode($response, true);

print_r($data);

print_r($data["localidade"]); // vai vir so o nome da cidade no array no indice/chave localidade

// /\ agora retorna em ARRAY.

/////////////////

Cookies -
Existe um local um pouco melhor q cookies, q é o local storage. Simplesmente diz pro php pra gravar o cookie na maquina do usuario e voce é obrigado a dizer quando aquele arquivo sai da máquina do usuario, pq basicamente vc ta gravando um arquivo na maquina do usuario, voce tem q dizer tbm quando o cookie expira. se vc não colocar uma data, na hora que fechar o navegador, o cookie morre. como gravar o cookie e como recuperar?
pra definir cookie é setcookie.

$data = array(
    "empresa"=>"Hcode"
);

setcookie("NOME_DO_COOKIE", json_encode($data), time() + 3600); // primeiro parametro é o nome do cookie, o segundo parametro é o que de fato voce quer armazenar, os dados no caso. as informaçoes de $data vou gravar dentro desse cookie temporario, em formato json. o terceiro parametro é definir quanto tempo voce quer que o cookie dure, senão, se fechar o navegador, o cookie vai demorar, até se reiniciar o PC o cookie pode durar. o cookie é persistente. o bizu é navegador anonimo, q mesmo que cookie persistente, ele morre. mesmo que seja em tempo, é tempo em timestamp.

echo "OK";

// no chrome, ao dar f12, vai em application, e la na esquerda tem 'cookies', que mostra os cookies gravados.

// agora, como recuperar um cookie caso ele exista?
// vejamos se um cookie existe:
if(isset($_COOKIE["NOME_DO_COOKIE"])) { // superarray e o nome do cookie
    $obj = var_dump(json_decode($_COOKIE["NOME_DO_COOKIE"])); // salvei em objeto, não coloquei 'true' no decode e ai veio em objeto.
    echo $obj->empresa; // pra acessar o atributo 'empresa' no objeto'
} 

////////////

TRATAMENTO DE ERROS TRY E CATCH -
try tenta, o catch 'captura', isto é, se deu algum erro ele vai pra lá.

<?php

try {

    throw new Exception("Houve um erro", 400); // esse numero é o numero do erro, vc pode se localizar atraves dele.

} catch (Exception $e) { // e esse $e é com o nome que eu quiser pra armazenar, pra armazenar a exceção.
    echo json_encode(array(
        "message"=>$e->getMessage(),
        "line"=>$e->getLine(),
        "file"=>$e->getFile(),
        "code"=>$e->getCode() // esses métodos getmessage, getline etc são métodos que já existem internamente dentro do exception.
    ));
}



?>

// o try e catch tem mais um bloco q não é obrigatorio mas vc pode usar. 
criar um bloco pra simular erro em tempo de execuçao:
se o usuario na hora de enviar não respeitou o que mandamos?

function trataNome($name) {
    if(!$name) { // se o $name vier vazio ou vier nada
        throw new Exception("Nenhum nome foi informado", 1);
    }

    echo ucfirst($name)."<br/>"; 
}

try {

    trataNome("João");
    trataNome("");

} catch(Exception $e) {

    echo $e->getMessage();

} finally { // e tem o bloco 'finally', que independente se executar o try ou catch, ele sempre vai executar por ultimo o bloco finally.
    echo "Executou o bloco Try";
}

//////////////

Tratando erros -
Existem outras ferramentas pra tratamento de erros pra contornar, neste caso não usaremos o throw new exception. temos os warnings e os notices. vamos ver um que, pode acontecer o erro, se acontecer, vc aborta e executa uma função.

// funçao pra manipular os erros
function error_handler($code, $message, $file, $line) {
    echo json_encode(array(
        "code"=>$code,
        "message"=>$message,
        "file"=>$file,
        "line"=>$line
    ));
}

set_error_handler("error_handler"); // ele espera o nome da funçao que vai manipular esse erro. como ele espera o nome da funçao, e nao a funçao em si, tem-se que colocar em aspas duplas, pq é uma string.

$total = 100 / 0; // vamos estourar um erro aqui, q é impossivel dividir algo por 0.

// agora com warnings:

error_reporting(E_ALL & ~E_NOTICE); // aqui voce escreve o que vc quer que apareça. vai sobrescrever oq tá dentro do php.ini. se eu colocar a constante E_ALL eu digo que quero mostrar todos os erros e não quero mostrar todas as noticias (o ~ é a negação)

$nome = $_GET["nome"];

echo $nome;

na url coloquemos:
http://localhost/arquivos/dir2.php?nome="luiz"
// vai mostrar normal, nao tem erro

////////////////

Gerando dependencias com o Composer
O composer é um gerenciador de dependencias do php, por ex, se vc fez um projeto em php q depende de uma lib. via composer vc tem um gerenciamneto de configuraçao dizendo tipo 'quem levar meu projeto precisa desse cara pra ser configurado etc'. Ele é baseado em JSON. É um controle de dependencias, ele organiza seu projeto, vai ter seu autoload padrão pra carregar as classes e vai carregar somente as necessarias pra dependencias dela, vc tbm pode pegar suas classes, colocar no github pra outras pessoas usarem, etc. 

no cmd digito: composer init

ou crio pasta 'composer' em htdocs e abro um git bash.

agora, vai perguntar o nome do pacote, no caso, <vendor>/<name>. o vendor pode ser o nome de usuario q vai ser unico no github, ou nome da empresa, enfim. o nome do vendor precisa ser unico, tem que ser seu. ex: hcodebr/composer -> vai pedir 'descrição', ai é ideal vc colocar algo mais formal. (não pode ter um repositorio com esse nome). o terceiro é o autor 'author', vc pode dar so enter se quiser, ou 'n' se pular. depois vai pedir estabilidade. ou deixa vazio para dizer que não tem uma versão específica estável. ou stable. ou 'rc' q é de release candidate(primeira versao), beta, alfa ou dev. (a ordem seria dev, alfa, beta, release candidate [rc] e depois stable ). depois pede o tipo de pacote, coloquemos 'project'. e depois pede a licença dizendo que vc que criou, etc. depois, pede as dependencias, isto é, doq ele depende ou não, do projeto e do desenvolvedor. ele vai mostrar como fica o JSON, e depois vai criar o arquivo JSON dentro do 'Composer' em htdocs.

dentro do require q tem no arquivo composer.json , posso colocar as dependencias que o projeto precisa pra funcionar. coloquemos "monolog/monolog", só por exemplo, isto é, nome do vendor e o nome do repositorio, e em seguida o nome da versão que vc espera que o composer baixe, ficando: "monolog/monolog":"1.0.*", vai baixar qualquer uma de 1.0 pra cima, pode ser 1.1.1 ou 1.1.2, ou 1.1.3, etc.

agora, no git, uso "composer install", que vai ler o arquivo json e vai procurar o que é dependencia que ainda não existe dentro do repositorio, mas ele so funciona na primeira vez que executa. na 2 vez, se vc adicionar ou remover dependencia, vai precisar usar outro comando, o 'composer update'.

dentro da pasta, vai ter o arquivo 'composer.lock', esse arquivo vai ter as informações do download que ele fez, dos repositorios q ele baixou, etc, nao precisa mexer nele. e vai criar a pasta 'vendor' tbm, que vai ter todos as pastas com todos os vendors que ele mandou baixar, que ele tem como dependencia. então, 'monolog' tbm pode ter suas dependencias e ter outras pastas que você não pediu, de acordo com a funcionalidade que ele tem pra poder funcionar.

agora, dentro do vendor tem o 'autoload.php', que com ELE você tem que se preocupar. ele é o autoload do composer, isto é, ele vai ter a inteligencia de carregar automaticamente assim que voce fizer o new, passando o namespace e o nome da classe que voce quer usar. o autoload do composer é um autoload mais polido, ele segue um padrão de uma entidade que segue as condutas de boa pratica. o php-fig.org define o que são boas praticas de programaçao, pra cada vez mais termos um php mais profissional. 

se vc precisar de outra dependencia que for externa, vc vai informar no seu php no seu composer.json, e vc digita o composer install ou o update e ja fica td certo.

///////////////

Envio de emails com PHPMailer
Vamos baixar o PHPMailer com o Composer.

Dentro do htdocs, criamos nova pasta chamada 'email'. dentro dela, vamos criar um novo arquivo chamado 'composer.json', escrevamos dentro:
{
    "require":{ // aqui precisamos colocar qual o vendor e qual o nome do phpmailer. podemos descobrir isso no github do projeto.
        "phpmailer/phpmailer": "^6.9.1" // Dentro do github do projeto tava la o vendor e o nome do projeto, versoes acima de 6.9.1
    }
}


/\ // apos salvar, agora basta abrir git bash na pasta e digitar 'composer update' pra baixar. criou os arquivos vendor, composer.lock na pasta.
vamos criar um arquivo index.php na pasta agora e digitar:

<?php

require_once("vendor/autoload.php"); 

// se vc ja tiver hospedagem de email pra enviar email, vc vai ter as configuraçoes de SMTP. nessa config vai ter a porta de onde o email vai sair e o endereço de IP do e-mail. servidor web != servidor de e-mail. de email vc vai ter um software especifico pra ter as portas pra receber e enviar email. 
// em nosso exemplo aqui vamos usar do gmail, basta ter conta de usuario no gmail. 
// o proprio phpmailer tem um exemplo, vai no github > examples > gmails.php


//Create a new PHPMailer instance
$mail = new PHPMailer();

//Tell PHPMailer to use SMTP
$mail->isSMTP();

//Enable SMTP debugging
//SMTP::DEBUG_OFF = off (for production use)
//SMTP::DEBUG_CLIENT = client messages
//SMTP::DEBUG_SERVER = client and server messages
$mail->SMTPDebug = SMTP::DEBUG_SERVER;

//Set the hostname of the mail server
$mail->Host = 'smtp.gmail.com';
//Use `$mail->Host = gethostbyname('smtp.gmail.com');`
//if your network does not support SMTP over IPv6,
//though this may cause issues with TLS

//Set the SMTP port number:
// - 465 for SMTP with implicit TLS, a.k.a. RFC8314 SMTPS or
// - 587 for SMTP+STARTTLS
$mail->Port = 465;

//Set the encryption mechanism to use:
// - SMTPS (implicit TLS on port 465) or
// - STARTTLS (explicit TLS on port 587)
$mail->SMTPSecure = PHPMailer::ENCRYPTION_SMTPS;

//Whether to use SMTP authentication
$mail->SMTPAuth = true;

//Username to use for SMTP authentication - use full email address for gmail
$mail->Username = 'username@gmail.com';

//Password to use for SMTP authentication
$mail->Password = 'yourpassword';

//Set who the message is to be sent from
//Note that with gmail you can only use your account address (same as `Username`)
//or predefined aliases that you have configured within your account.
//Do not use user-submitted addresses in here
$mail->setFrom('from@example.com', 'First Last');

//Set an alternative reply-to address
//This is a good place to put user-submitted addresses
$mail->addReplyTo('replyto@example.com', 'First Last');

//Set who the message is to be sent to
$mail->addAddress('whoto@example.com', 'John Doe');

//Set the subject line
$mail->Subject = 'PHPMailer GMail SMTP test';

//Read an HTML message body from an external file, convert referenced images to embedded,
//convert HTML into a basic plain-text alternative body
$mail->msgHTML(file_get_contents('contents.html'), __DIR__);

//Replace the plain text body with one created manually
$mail->AltBody = 'This is a plain-text message body';

//Attach an image file
$mail->addAttachment('images/phpmailer_mini.png');

//send the message, check for errors
if (!$mail->send()) {
    echo 'Mailer Error: ' . $mail->ErrorInfo;
} else {
    echo 'Message sent!';
    //Section 2: IMAP
    //Uncomment these to save your message in the 'Sent Mail' folder.
    #if (save_mail($mail)) {
    #    echo "Message saved!";
    #}
}

//Section 2: IMAP
//IMAP commands requires the PHP IMAP Extension, found at: https://php.net/manual/en/imap.setup.php
//Function to call which uses the PHP imap_*() functions to save messages: https://php.net/manual/en/book.imap.php
//You can use imap_getmailboxes($imapStream, '/imap/ssl', '*' ) to get a list of available folders or labels, this can
//be useful if you are trying to get this working on a non-Gmail IMAP server.
function save_mail($mail)
{
    //You can change 'Sent Mail' to any other folder or tag
    $path = '{imap.gmail.com:993/imap/ssl}[Gmail]/Sent Mail';

    //Tell your server to open an IMAP connection using the same username and password as you used for SMTP
    $imapStream = imap_open($path, $mail->Username, $mail->Password);

    $result = imap_append($imapStream, $path, $mail->getSentMIMEMessage());
    imap_close($imapStream);

    return $result;
}

// /\ o método IsSMTP é um metodo q prepara o phpmailer pra enviar um email. SMTP::DEBUG_SERVER é melhor pra ambientes de desenvolvimento.

// o arquivo 'contents.html' deve existir na pasta onde ta o arquivo desse codigo, q é onde vai ter o corpo dessa página.

// altbody é alternative body, texto alternativo se o principal, q é dentro do contents.html, n funcionar

?> 